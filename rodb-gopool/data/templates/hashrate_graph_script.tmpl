{{define "hashrate_graph_script"}}
<script>
// Pool Hashrate Graph
(function() {
	const canvas = document.getElementById('{{.HashrateGraphID}}');
	if (!canvas) return;

	// Set canvas size to match display size for crisp rendering
	function resizeCanvas() {
		const dpr = window.devicePixelRatio || 1;
		const rect = canvas.getBoundingClientRect();
		canvas.width = rect.width * dpr;
		canvas.height = rect.height * dpr;
		const ctx = canvas.getContext('2d');
		ctx.scale(dpr, dpr);
		return ctx;
	}

	let ctx = resizeCanvas();

	// Re-render on window resize
	window.addEventListener('resize', function() {
		ctx = resizeCanvas();
		drawGraph();
	});
	const sampleIntervalMS = 5000;
	const historyWindowMS = 6 * 60 * 1000;
	const maxDataPoints = Math.floor(historyWindowMS / sampleIntervalMS); // 6 minutes at 5-second intervals
	const hashrateData = [];
	const timestamps = [];
	const blockHeights = [];
	let smoothedHashrate = null;
	let lastBlockHeight = null;
	let historyPrimed = false;

	function trimHistory() {
		const cutoff = Date.now() - historyWindowMS;
		while (timestamps.length > 0) {
			const ts = timestamps[0];
			if (!(ts instanceof Date) || Number.isNaN(ts.getTime()) || ts.getTime() < cutoff) {
				hashrateData.shift();
				timestamps.shift();
				blockHeights.shift();
				continue;
			}
			break;
		}
		while (hashrateData.length > maxDataPoints) {
			hashrateData.shift();
			timestamps.shift();
			blockHeights.shift();
		}
	}

	function primeHashrateGraphHistory(history) {
		if (!Array.isArray(history) || historyPrimed) {
			return false;
		}
		const cutoff = Date.now() - historyWindowMS;
		const rows = history
			.map(row => {
				const hashrate = Number(row && row.hashrate);
				const ts = Date.parse(row && row.at);
				const blockHeight = Number(row && row.block_height);
				return {
					hashrate,
					timestamp: ts,
					blockHeight: Number.isFinite(blockHeight) && blockHeight > 0 ? blockHeight : null,
				};
			})
			.filter(row => Number.isFinite(row.hashrate) && row.hashrate > 0 && Number.isFinite(row.timestamp) && row.timestamp >= cutoff)
			.sort((a, b) => a.timestamp - b.timestamp);

		if (rows.length === 0) {
			return false;
		}
		hashrateData.length = 0;
		timestamps.length = 0;
		blockHeights.length = 0;
		rows.forEach(row => {
			hashrateData.push(row.hashrate);
			timestamps.push(new Date(row.timestamp));
			blockHeights.push(row.blockHeight);
			if (row.blockHeight) {
				lastBlockHeight = row.blockHeight;
			}
		});
		trimHistory();
		if (hashrateData.length > 0) {
			smoothedHashrate = hashrateData[hashrateData.length - 1];
		}
		historyPrimed = true;
		drawGraph();
		return true;
	}

		function drawGraph() {
		// Use display dimensions (logical pixels) for drawing
		const rect = canvas.getBoundingClientRect();
		const width = rect.width;
		const height = rect.height;
		const paddingLeft = 90; // Extra padding for Y-axis labels
		const paddingRight = 20;
		const paddingTop = 20;
		const paddingBottom = 30;
			const graphWidth = width - paddingLeft - paddingRight;
			const graphHeight = height - paddingTop - paddingBottom;
			const nowMillis = Date.now();
			const windowStartMillis = nowMillis - historyWindowMS;
			const windowSpan = historyWindowMS;

			function xForPoint(index) {
				const ts = timestamps[index];
				if (!(ts instanceof Date) || Number.isNaN(ts.getTime())) {
					const denom = Math.max(1, maxDataPoints - 1);
					return paddingLeft + (graphWidth / denom) * index;
				}
				const ratio = Math.max(0, Math.min(1, (ts.getTime() - windowStartMillis) / windowSpan));
				return paddingLeft + ratio * graphWidth;
			}

		// Clear canvas
		ctx.clearRect(0, 0, width, height);

		if (hashrateData.length === 0) {
			ctx.fillStyle = '#b3bbd4';
			ctx.font = '14px monospace';
			ctx.textAlign = 'center';
			ctx.fillText('Waiting for data...', width / 2, height / 2);
			return;
		}

		// Find min/max for scaling, with headroom so peaks don't peg the top.
		// Keep a minimum Y-axis floor so low-hashrate pools aren't rendered
		// against an always-zero baseline.
		const minScale = 0;
		const dataMax = Math.max(...hashrateData);

		const headroomFactor = 2.0;
		const defaultMaxScale = 100e3; // 100 kH/s in H/s
		const maxHashrate = Math.max(dataMax * headroomFactor, defaultMaxScale);
		const minHashrate = minScale;
		const range = Math.max(1, maxHashrate - minHashrate);

		// Draw grid lines
		ctx.strokeStyle = '#2a2f3a';
		ctx.lineWidth = 1;
		for (let i = 0; i <= 4; i++) {
			const y = paddingTop + (graphHeight / 4) * i;
			ctx.beginPath();
			ctx.moveTo(paddingLeft, y);
			ctx.lineTo(width - paddingRight, y);
			ctx.stroke();
		}

		// Draw Y-axis labels (hashrate)
		ctx.fillStyle = '#b3bbd4';
		ctx.font = '11px monospace';
		ctx.textAlign = 'right';
		for (let i = 0; i <= 4; i++) {
			const y = paddingTop + (graphHeight / 4) * i;
			const value = maxHashrate - (range / 4) * i;
			const formatted = formatHashrateShort(value);
			ctx.fillText(formatted, paddingLeft - 8, y + 4);
		}

		// Draw block-height change markers (vertical dividers with labels).
		if (blockHeights.length > 1) {
			ctx.save();
			ctx.strokeStyle = '#f3d36b';
			ctx.fillStyle = '#f3d36b';
			ctx.lineWidth = 1;
			ctx.setLineDash([4, 3]);
			ctx.font = '11px monospace';
				for (let i = 1; i < blockHeights.length; i++) {
				const prev = blockHeights[i - 1];
				const cur = blockHeights[i];
				if (!prev || !cur || cur === prev) {
					continue;
				}
					const x = xForPoint(i);
				ctx.beginPath();
				ctx.moveTo(x, paddingTop);
				ctx.lineTo(x, height - paddingBottom);
				ctx.stroke();
				ctx.setLineDash([]);
				const label = `#${cur}`;
				const labelY = paddingTop + 12;
				const paddingX = 6;
				const maxX = width - paddingRight - paddingX;
				const desiredX = x + paddingX;
				if (desiredX > maxX) {
					ctx.textAlign = 'right';
					ctx.fillText(label, x - paddingX, labelY);
				} else {
					ctx.textAlign = 'left';
					ctx.fillText(label, desiredX, labelY);
				}
				ctx.setLineDash([4, 3]);
			}
			ctx.restore();
		}

		// Draw the line graph
			ctx.strokeStyle = '#4a9eff';
			ctx.lineWidth = 2;
			ctx.beginPath();
			hashrateData.forEach((hashrate, index) => {
				const x = xForPoint(index);
				const y = paddingTop + (graphHeight * (1 - (hashrate - minHashrate) / range));
				if (index === 0) ctx.moveTo(x, y);
				else ctx.lineTo(x, y);
			});
		ctx.stroke();

		// Draw X-axis tick marks (no labels)
		ctx.strokeStyle = '#ffffff';
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(paddingLeft, height - paddingBottom);
		ctx.lineTo(width - paddingRight, height - paddingBottom);
		ctx.stroke();
		const interval = Math.floor(maxDataPoints / 6);
		for (let i = 0; i < maxDataPoints; i += interval) {
			const x = paddingLeft + (graphWidth / (maxDataPoints - 1)) * i;
			ctx.beginPath();
			ctx.moveTo(x, height - paddingBottom);
			ctx.lineTo(x, height - paddingBottom + 5);
			ctx.stroke();
		}

		// Draw "minutes" label centered below the axis (no numeric labels)
		ctx.fillStyle = '#b3bbd4';
		ctx.font = '10px monospace';
		ctx.textAlign = 'center';
		ctx.fillText('minutes', paddingLeft + graphWidth / 2, height - 5);

		// Draw data points
			ctx.fillStyle = '#4a9eff';
			hashrateData.forEach((hashrate, index) => {
				const x = xForPoint(index);
				const y = paddingTop + (graphHeight * (1 - (hashrate - minHashrate) / range));
				ctx.beginPath();
				ctx.arc(x, y, 2, 0, Math.PI * 2);
			ctx.fill();
		});
	}

	function formatHashrateShort(h) {
		if (!h) return '0';
		const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
		let val = h, idx = 0;
		while (val >= 1000 && idx < units.length - 1) {
			val /= 1000;
			idx++;
		}
		return val.toFixed(1) + ' ' + units[idx];
	}

		function updateHashrateGraph(newHashrate, blockHeight) {
			if (!newHashrate || newHashrate <= 0) return;

		const effectiveBlockHeight = typeof blockHeight === 'number' && blockHeight > 0 ? blockHeight : lastBlockHeight;
		if (typeof blockHeight === 'number' && blockHeight > 0) {
			lastBlockHeight = blockHeight;
		}

			let nextHashrate = newHashrate;
			if (!historyPrimed) {
				// Before server-side history is primed, apply a light EMA so
				// early points don't jump sharply between polls.
				if (smoothedHashrate === null) {
					smoothedHashrate = newHashrate;
				} else {
					const alpha = 0.25; // smoothing factor (0..1); lower = smoother
					smoothedHashrate = smoothedHashrate + alpha * (newHashrate - smoothedHashrate);
				}
				nextHashrate = smoothedHashrate;
			}

			hashrateData.push(nextHashrate);
		timestamps.push(new Date());
		blockHeights.push(effectiveBlockHeight || null);

		trimHistory();

		drawGraph();
	}

	// Initial draw
	drawGraph();

	// Expose update function globally so auto-refresh can call it
	window.updateHashrateGraph = updateHashrateGraph;
	window.primeHashrateGraphHistory = primeHashrateGraphHistory;

	// Redraw on window resize
	window.addEventListener('resize', drawGraph);
})();
</script>
{{end}}
