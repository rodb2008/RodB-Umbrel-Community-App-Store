{{define "hashrate_graph_script"}}
<script>
// Pool Hashrate Graph
(function() {
	const canvas = document.getElementById('{{.HashrateGraphID}}');
	if (!canvas) return;

	// Set canvas size to match display size for crisp rendering
	function resizeCanvas() {
		const dpr = window.devicePixelRatio || 1;
		const rect = canvas.getBoundingClientRect();
		canvas.width = rect.width * dpr;
		canvas.height = rect.height * dpr;
		const ctx = canvas.getContext('2d');
		ctx.scale(dpr, dpr);
		return ctx;
	}

	let ctx = resizeCanvas();

	// Re-render on window resize
	window.addEventListener('resize', function() {
		ctx = resizeCanvas();
		drawGraph();
	});
	const sampleIntervalMS = 5000;
	const historyWindowMS = 6 * 60 * 1000;
	const maxDataPoints = Math.floor(historyWindowMS / sampleIntervalMS); // 6 minutes at 5-second intervals
	const hashrateData = [];
	const timestamps = [];
	const blockHeights = [];
	let smoothedHashrate = null;
	let lastBlockHeight = null;
	let historyPrimed = false;

	function trimHistory() {
		const cutoff = Date.now() - historyWindowMS;
		while (timestamps.length > 0) {
			const ts = timestamps[0];
			if (!(ts instanceof Date) || Number.isNaN(ts.getTime()) || ts.getTime() < cutoff) {
				hashrateData.shift();
				timestamps.shift();
				blockHeights.shift();
				continue;
			}
			break;
		}
		while (hashrateData.length > maxDataPoints) {
			hashrateData.shift();
			timestamps.shift();
			blockHeights.shift();
		}
	}

	function decodeHashrateSI8(code) {
		const c = Number(code);
		if (!Number.isFinite(c) || c <= 0) return 0;
		const mantBits = 5;
		const maxExp = 7;
		const mantMask = (1 << mantBits) - 1;
		const exp = Math.floor((c >> mantBits) & maxExp);
		const q = Math.floor(c & mantMask);
		if (q <= 0) return 0;
		const logT = (q - 1) / (mantMask - 1);
		let value = Math.pow(1000, logT);
		for (let i = 0; i < exp; i++) {
			value *= 1000;
		}
		return value;
	}

	function primeHashrateGraphHistory(history) {
		if (!Array.isArray(history) || historyPrimed) {
			return false;
		}
		const decoded = history
			.map(code => decodeHashrateSI8(code))
			.filter(v => Number.isFinite(v) && v > 0);
		if (decoded.length === 0) {
			return false;
		}
		const now = Date.now();
		const span = decoded.length > 1 ? (historyWindowMS / (decoded.length - 1)) : 0;
		hashrateData.length = 0;
		timestamps.length = 0;
		blockHeights.length = 0;
		decoded.forEach((hashrate, idx) => {
			hashrateData.push(hashrate);
			const offset = span * (decoded.length - 1 - idx);
			timestamps.push(new Date(now - offset));
			blockHeights.push(null);
		});
		trimHistory();
		if (hashrateData.length > 0) {
			smoothedHashrate = hashrateData[hashrateData.length - 1];
		}
		historyPrimed = true;
		drawGraph();
		return true;
	}

	function buildQuantizedBucketRects(xPixelsInput, minBound, maxBound, fallbackWidth) {
		const xPixels = (Array.isArray(xPixelsInput) ? xPixelsInput : [])
			.map(v => Math.round(Number(v)))
			.filter(v => Number.isFinite(v));
		const n = xPixels.length;
		const leftBound = Math.max(0, Math.round(Number(minBound) || 0));
		const rightBound = Math.max(leftBound + 1, Math.round(Number(maxBound) || 0));
		if (n === 0) return [];
		if (n === 1) {
			const w = Math.max(1, Math.min(rightBound - leftBound, Math.round(Number(fallbackWidth) || 1)));
			const left = Math.max(leftBound, Math.min(rightBound - w, xPixels[0] - Math.floor(w / 2)));
			return [{ left, width: w }];
		}
		const edges = new Array(n + 1);
		edges[0] = Math.max(leftBound, Math.round(xPixels[0] - (xPixels[1] - xPixels[0]) / 2));
		for (let i = 1; i < n; i++) {
			edges[i] = Math.round((xPixels[i - 1] + xPixels[i]) / 2);
		}
		edges[n] = Math.min(rightBound, Math.round(xPixels[n - 1] + (xPixels[n - 1] - xPixels[n - 2]) / 2));
		edges[0] = Math.max(leftBound, Math.min(rightBound - n, edges[0]));
		for (let i = 1; i < n; i++) {
			const minEdge = edges[i - 1] + 1;
			const maxEdge = rightBound - (n - i);
			edges[i] = Math.max(minEdge, Math.min(maxEdge, edges[i]));
		}
		edges[n] = rightBound;
		if (edges[n] <= edges[n - 1]) edges[n] = edges[n - 1] + 1;
		const rects = new Array(n);
		for (let i = 0; i < n; i++) {
			const left = edges[i];
			const right = Math.max(left + 1, edges[i + 1]);
			rects[i] = { left, width: right - left };
		}
		return rects;
	}

	function blockMarkerColor() {
		const isLight = document.documentElement && document.documentElement.getAttribute('data-theme') === 'light';
		return isLight ? '#8f6a00' : '#f3d36b';
	}

	function graphLabelColor() {
		const isLight = document.documentElement && document.documentElement.getAttribute('data-theme') === 'light';
		return isLight ? '#4b5568' : '#b3bbd4';
	}

		function drawGraph() {
		// Use display dimensions (logical pixels) for drawing
		const rect = canvas.getBoundingClientRect();
		const width = rect.width;
		const height = rect.height;
		const paddingLeft = 90; // Extra padding for Y-axis labels
		const paddingRight = 20;
		const paddingTop = 20;
		const paddingBottom = 30;
			const graphWidth = width - paddingLeft - paddingRight;
			const graphHeight = height - paddingTop - paddingBottom;
			const nowMillis = Date.now();
			const windowStartMillis = nowMillis - historyWindowMS;
			const windowSpan = historyWindowMS;

			function xForPoint(index) {
				const ts = timestamps[index];
				if (!(ts instanceof Date) || Number.isNaN(ts.getTime())) {
					const denom = Math.max(1, maxDataPoints - 1);
					return paddingLeft + (graphWidth / denom) * index;
				}
				const ratio = Math.max(0, Math.min(1, (ts.getTime() - windowStartMillis) / windowSpan));
				return paddingLeft + ratio * graphWidth;
			}

		// Clear canvas
		ctx.clearRect(0, 0, width, height);

		if (hashrateData.length === 0) {
			ctx.fillStyle = graphLabelColor();
			ctx.font = '14px monospace';
			ctx.textAlign = 'center';
			ctx.fillText('Waiting for data...', width / 2, height / 2);
			return;
		}

		// Find min/max for scaling, with headroom so peaks don't peg the top.
		// Keep a minimum Y-axis floor so low-hashrate pools aren't rendered
		// against an always-zero baseline.
		const minScale = 0;
		const dataMax = Math.max(...hashrateData);

		const headroomFactor = 1.25;
		const defaultMaxScale = 100e3; // 100 kH/s in H/s
		const maxHashrate = Math.max(dataMax * headroomFactor, defaultMaxScale);
		const minHashrate = minScale;
		const range = Math.max(1, maxHashrate - minHashrate);

		// Draw grid lines
		ctx.strokeStyle = '#2a2f3a';
		ctx.lineWidth = 1;
		for (let i = 0; i <= 4; i++) {
			const y = paddingTop + (graphHeight / 4) * i;
			ctx.beginPath();
			ctx.moveTo(paddingLeft, y);
			ctx.lineTo(width - paddingRight, y);
			ctx.stroke();
		}

		// Draw Y-axis labels (hashrate)
		ctx.fillStyle = graphLabelColor();
		ctx.font = '11px monospace';
		ctx.textAlign = 'right';
		for (let i = 0; i <= 4; i++) {
			const y = paddingTop + (graphHeight / 4) * i;
			const value = maxHashrate - (range / 4) * i;
			const formatted = formatHashrateShort(value);
			ctx.fillText(formatted, paddingLeft - 8, y + 4);
		}

		// Draw block-height change markers (vertical dividers with labels).
		if (blockHeights.length > 1) {
			const markerColor = blockMarkerColor();
			ctx.save();
			ctx.strokeStyle = markerColor;
			ctx.fillStyle = markerColor;
			ctx.lineWidth = 1;
			ctx.setLineDash([4, 3]);
			ctx.font = '11px monospace';
				for (let i = 1; i < blockHeights.length; i++) {
				const prev = blockHeights[i - 1];
				const cur = blockHeights[i];
				if (!prev || !cur || cur === prev) {
					continue;
				}
					const x = xForPoint(i);
				ctx.beginPath();
				ctx.moveTo(x, paddingTop);
				ctx.lineTo(x, height - paddingBottom);
				ctx.stroke();
				ctx.setLineDash([]);
				const label = `#${cur}`;
				const labelY = paddingTop + 12;
				const paddingX = 6;
				const maxX = width - paddingRight - paddingX;
				const desiredX = x + paddingX;
				if (desiredX > maxX) {
					ctx.textAlign = 'right';
					ctx.fillText(label, x - paddingX, labelY);
				} else {
					ctx.textAlign = 'left';
					ctx.fillText(label, desiredX, labelY);
				}
				ctx.setLineDash([4, 3]);
			}
			ctx.restore();
		}

		// Draw quantized bars (touching, no gaps)
		const xPixels = hashrateData.map((_, index) => xForPoint(index));
		const rects = buildQuantizedBucketRects(
			xPixels,
			paddingLeft,
			width - paddingRight,
			Math.max(2, Math.ceil(graphWidth / 32)),
		);
		const baselineY = Math.round(height - paddingBottom);
		ctx.fillStyle = 'rgba(74, 158, 255, 0.45)';
		ctx.strokeStyle = blockMarkerColor();
		ctx.lineWidth = 2;
		hashrateData.forEach((hashrate, index) => {
			const rect = rects[index];
			if (!rect) return;
			const y = paddingTop + (graphHeight * (1 - (hashrate - minHashrate) / range));
			const top = Math.round(Math.max(paddingTop, Math.min(baselineY, y)));
			let h = baselineY - top;
			if (h <= 0) h = 1;
			ctx.fillRect(rect.left, baselineY - h, rect.width, h);
			ctx.beginPath();
			ctx.moveTo(rect.left, top);
			ctx.lineTo(rect.left + rect.width, top);
			ctx.stroke();
		});

		// Draw X-axis tick marks (no labels)
		ctx.strokeStyle = '#ffffff';
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(paddingLeft, height - paddingBottom);
		ctx.lineTo(width - paddingRight, height - paddingBottom);
		ctx.stroke();
		const interval = Math.floor(maxDataPoints / 6);
		for (let i = 0; i < maxDataPoints; i += interval) {
			const x = paddingLeft + (graphWidth / (maxDataPoints - 1)) * i;
			ctx.beginPath();
			ctx.moveTo(x, height - paddingBottom);
			ctx.lineTo(x, height - paddingBottom + 5);
			ctx.stroke();
		}

		// Draw "minutes" label centered below the axis (no numeric labels)
		ctx.fillStyle = graphLabelColor();
		ctx.font = '10px monospace';
		ctx.textAlign = 'center';
		ctx.fillText('minutes', paddingLeft + graphWidth / 2, height - 5);

	}

	function formatHashrateShort(h) {
		if (!h) return '0';
		const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
		let val = h, idx = 0;
		while (val >= 1000 && idx < units.length - 1) {
			val /= 1000;
			idx++;
		}
		return val.toFixed(1) + ' ' + units[idx];
	}

		function updateHashrateGraph(newHashrate, blockHeight) {
			if (!newHashrate || newHashrate <= 0) return;

		const effectiveBlockHeight = typeof blockHeight === 'number' && blockHeight > 0 ? blockHeight : lastBlockHeight;
		if (typeof blockHeight === 'number' && blockHeight > 0) {
			lastBlockHeight = blockHeight;
		}

			let nextHashrate = newHashrate;
			if (!historyPrimed) {
				// Before server-side history is primed, apply a light EMA so
				// early points don't jump sharply between polls.
				if (smoothedHashrate === null) {
					smoothedHashrate = newHashrate;
				} else {
					const alpha = 0.25; // smoothing factor (0..1); lower = smoother
					smoothedHashrate = smoothedHashrate + alpha * (newHashrate - smoothedHashrate);
				}
				nextHashrate = smoothedHashrate;
			}

			hashrateData.push(nextHashrate);
		timestamps.push(new Date());
		blockHeights.push(effectiveBlockHeight || null);

		trimHistory();

		drawGraph();
	}

	// Initial draw
	drawGraph();

	// Expose update function globally so auto-refresh can call it
	window.updateHashrateGraph = updateHashrateGraph;
	window.primeHashrateGraphHistory = primeHashrateGraphHistory;

	// Redraw on window resize
	window.addEventListener('resize', drawGraph);
})();
</script>
{{end}}
