{{/* Saved workers page template */}}
<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="icon" type="image/png" sizes="64x64" href="/favicon.png">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{{if .BrandDomain}}{{.BrandDomain}}{{else}}{{.BrandName}}{{end}} â€” Saved Workers</title>
	<link rel="stylesheet" href="/style.css">
	<style>
		.discord-dialog {
			max-width: 560px;
			width: calc(100vw - 32px);
			border: 1px solid #2a2f3a;
			border-radius: 12px;
			padding: 0;
			background: #0f1218;
			color: var(--text, #e8ecf7);
			box-shadow: 0 18px 60px rgba(0,0,0,0.6);
		}
		.discord-dialog::backdrop { background: rgba(0,0,0,0.55); }
		.discord-dialog-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			padding: 14px 14px 10px 14px;
			border-bottom: 1px solid #242a36;
		}
		.discord-dialog-body { padding: 14px; }
		.discord-dialog-code {
			display: flex;
			align-items: center;
			gap: 10px;
			flex-wrap: wrap;
			margin-top: 10px;
		}
		.discord-dialog-code .mono {
			padding: 8px 10px;
			border-radius: 10px;
			background: #0b0d12;
			border: 1px solid #2a2f3a;
			cursor: pointer;
			user-select: all;
		}
		.discord-dialog-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }

		.offline-list li {
			display: grid;
			grid-template-columns: 1fr auto auto auto;
			align-items: center;
			gap: 10px;
		}
		.offline-worker-meta { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
		.offline-worker-meta a { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
		.offline-last-online { color: var(--text-muted); }
		@media (max-width: 540px) {
			.offline-list li {
				grid-template-columns: 1fr auto;
				grid-template-rows: auto auto;
				align-items: start;
			}
			.offline-list li .offline-actions {
				grid-column: 1 / -1;
				display: flex;
				justify-content: flex-end;
				gap: 8px;
			}
		}
		.hashrate-settling {
			opacity: 0.82;
		}
		.hashrate-warming {
			opacity: 0.72;
		}
		.hashrate-solid {
			opacity: 1;
		}
	</style>
</head>
<body>
	{{template "header" .}}
	<main class="page" id="content">
		<noscript>
			<div class="card">
				<p class="text-sm" style="color:#f88d8d;margin:0;">
					JavaScript is required to use the saved workers dashboard.
				</p>
			</div>
		</noscript>
		{{if .ClerkUser}}
		<div class="panel-stack panel-stack-wide">
			<div class="saved-workers-status">
				{{template "status_boxes" .}}
			</div>

			<div class="card">
				<div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
					<div>
						<p class="text-sm" style="margin:0; color:var(--text-muted);">Best difficulty (any saved worker)</p>
						<div class="mono" id="savedBestDiffValue" style="font-size:1.2rem;">{{formatDiff .SavedWorkersBestDifficulty}}</div>
					</div>
				</div>
			</div>

			{{template "hashrate_graph" .}}

			<div class="card" id="onlineWorkersCard" {{if not .OnlineWorkerEntries}}style="display:none;"{{end}}>
				<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
					<h2 style="margin-top:0;">Your workers</h2>
					<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
						<span class="badge">Slots: <span id="savedCount">{{.SavedWorkersCount}}</span> / <span id="savedMax">{{.SavedWorkersMax}}</span></span>
						<span class="badge">Online: <span id="onlineCount">{{.SavedWorkersOnline}}</span></span>
					</div>
				</div>
				<p class="text-sm" style="color:var(--text-muted); margin:8px 0 0;">
					Note: For workers sharing the same wallet and name, only the first 16 are displayed here.
				</p>
				<p class="text-sm" style="color:var(--text-muted); margin:6px 0 0;">
					Force reset button: bans for 30s, then disconnects active sessions so the miner reconnects cleanly.
				</p>
				<p class="text-sm" style="color:var(--text-muted); margin:6px 0 0;">
					Hashrate markers: <span class="mono">~</span> warming, <span class="mono">â‰ˆ</span> settling, stable (no symbol).
				</p>
				<div class="saved-workers-sort" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-top:10px;">
					<label class="text-sm mono" for="savedWorkersSortField" style="margin:0;">Sort by</label>
					<select id="savedWorkersSortField" class="input" style="max-width:220px;">
						<option value="connection_seq">Connection #</option>
						<option value="name">Name</option>
						<option value="hashrate">Hashrate</option>
					</select>
					<button id="savedWorkersSortOrder" class="btn btn-secondary" type="button" aria-label="Toggle sort order">Desc â†“</button>
				</div>
				<div style="overflow-x:auto; margin-top:12px;">
					<table class="table">
					<thead>
						<tr>
							<th>Worker</th>
							<th>Hashrate</th>
							<th>Best share</th>
							<th>Diff</th>
							<th>Shares/min</th>
							<th>Last share</th>
							<th>Accepted</th>
							<th>Rejected</th>
							<th>Miner Response</th>
							<th>Work Start</th>
							<th>Connected</th>
							<th></th>
						</tr>
					</thead>
						<tbody id="onlineWorkersBody">
							{{if .OnlineWorkerEntries}}
								{{range .OnlineWorkerEntries}}
					<tr>
						<td><a class="mono sensitive-worker worker-link" data-worker-name="{{.Name}}" data-worker-hash="{{.Hash}}" href="/worker/sha256?hash={{.Hash}}"></a></td>
							<td data-hashrate="{{printf "%.0f" .Hashrate}}" data-hashrate-accuracy="{{.HashrateAccuracy}}" class="hashrate-value">â€”</td>
						<td>{{formatDiff .BestDifficulty}}</td>
						<td>{{formatDiff .Difficulty}}</td>
						<td>{{formatShareRate .ShareRate}}</td>
						<td>{{formatTime .LastShare}}</td>
						<td>{{.Accepted}}</td>
						<td>{{.Rejected}}</td>
						<td class="latency-pair" data-rtt-p50-ms="{{printf "%.6f" .EstimatedPingP50MS}}" data-rtt-p95-ms="{{printf "%.6f" .EstimatedPingP95MS}}">â€”</td>
						<td class="latency-pair-work" data-work-min-ms="{{printf "%.6f" .NotifyToFirstShareMinMS}}" data-work-p50-ms="{{printf "%.6f" .NotifyToFirstShareP50MS}}" data-work-p95-ms="{{printf "%.6f" .NotifyToFirstShareP95MS}}" data-work-last-ms="{{printf "%.6f" .NotifyToFirstShareMS}}" data-work-samples="{{.NotifyToFirstShareSamples}}">â€”</td>
						<td>{{humanDuration .ConnectedDuration}}</td>
						<td style="text-align:right;">
										<div style="display:flex; gap:8px; justify-content:flex-end; align-items:center;">
											{{if $.DiscordNotificationsEnabled}}
												<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="{{.Hash}}" data-notify-enabled="{{if .NotifyEnabled}}1{{else}}0{{end}}" aria-label="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}" title="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}">
													{{if .NotifyEnabled}}ðŸ””{{else}}ðŸ”•{{end}}
												</button>
											{{end}}
											<form method="post" action="/worker/reconnect" style="margin:0;" data-reconnect-worker="{{.Name}}">
												<input type="hidden" name="hash" value="{{.Hash}}">
											<button class="btn btn-secondary" type="submit" aria-label="Force reset worker" title="Force reset (30s ban + disconnect)">
												Force reset
											</button>
										</form>
											<form method="post" action="/worker/remove" style="margin:0;" data-remove-worker="{{.Name}}">
												<input type="hidden" name="hash" value="{{.Hash}}">
												<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
													<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
														<polyline points="3 6 5 6 21 6"></polyline>
														<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
														<path d="M10 11v6"></path>
														<path d="M14 11v6"></path>
														<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
													</svg>
												</button>
											</form>
										</div>
									</td>
								</tr>
								{{end}}
							{{else}}
								<tr><td colspan="12" class="text-sm">No saved workers online right now.</td></tr>
							{{end}}
						</tbody>
					</table>
				</div>
			</div>

			{{$offlineCount := len .OfflineWorkerEntries}}
			<div class="card offline-card" id="offlineSection" {{if eq $offlineCount 0}}style="display:none;"{{end}}>
				<div class="offline-card-header">
					<div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
						<h2 style="margin:0;">Offline Workers</h2>
						<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;">
							<span class="badge badge-danger" id="offlineCountBadge" style="margin-left:8px; {{if eq $offlineCount 0}}display:none;{{end}}">
								{{$offlineCount}} offline
							</span>
						</div>
					</div>
				</div>
				<ul class="offline-list text-sm" id="offlineWorkersList" {{if eq $offlineCount 0}}style="display:none;"{{end}}>
					{{range .OfflineWorkerEntries}}
						<li>
								<div class="offline-worker-meta">
									<a class="mono sensitive-worker worker-link" data-worker-name="{{.Name}}" data-worker-hash="{{.Hash}}" href="/worker/sha256?hash={{.Hash}}"></a>
									<span class="text-sm offline-last-online" data-last-online-at="{{.LastOnlineAt}}"></span>
									<span class="text-sm" style="color:var(--text-muted);">Best share: {{formatDiff .BestDifficulty}}</span>
								</div>
							<span class="badge badge-danger">Offline</span>
							<div class="offline-actions" style="display:flex; gap:8px; justify-content:flex-end; align-items:center;">
							{{if $.DiscordNotificationsEnabled}}
									<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="{{.Hash}}" data-notify-enabled="{{if .NotifyEnabled}}1{{else}}0{{end}}" aria-label="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}" title="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}">
										{{if .NotifyEnabled}}ðŸ””{{else}}ðŸ”•{{end}}
									</button>
								{{end}}
								<form method="post" action="/worker/remove" style="margin:0;" data-remove-worker="{{.Name}}">
									<input type="hidden" name="hash" value="{{.Hash}}">
									<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
										<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
											<polyline points="3 6 5 6 21 6"></polyline>
											<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
											<path d="M10 11v6"></path>
											<path d="M14 11v6"></path>
											<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
										</svg>
									</button>
								</form>
							</div>
						</li>
					{{end}}
				</ul>
				<p id="offlineEmptyMessage" class="text-sm" style="color:var(--text-muted); margin-top:10px; display:none;">
					All saved workers are currently online.
				</p>
			</div>

			<div class="card">
				<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
					<h2 style="margin-top:0;">
						{{if eq .SavedWorkersCount 0}}
							Add your first worker!
						{{else}}
							Add workers
						{{end}}
					</h2>
				</div>
				<form method="post" action="/worker/save" style="margin-top:12px;">
					<div class="input-row">
						<input class="input" type="text" name="worker" placeholder="wallet.worker">
						<button class="btn" type="submit">Add</button>
					</div>
				</form>
			</div>

			<div class="card">
				<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
					<div>
						<h2 style="margin-top:0;">Find miners by wallet</h2>
						<p class="text-sm" style="color:var(--text-muted); margin:4px 0 0;">
							Paste a wallet address to list active workers using it and save them without duplicates.
						</p>
					</div>
				</div>
				<form method="get" action="/saved-workers" id="walletLookupForm" style="margin-top:12px;">
					<div class="label">Wallet address</div>
					<div class="input-row">
						<input class="input" type="text" id="walletLookupInput" name="wallet" placeholder="bc1..." autocomplete="off">
						<input type="hidden" name="hash" id="walletLookupHash" value="{{.WalletLookupHash}}">
						<button class="btn" type="submit">Search wallet</button>
					</div>
				</form>
				{{if .WalletLookupError}}
					<p class="text-sm" style="color:#f88d8d; margin-top:10px;">{{.WalletLookupError}}</p>
				{{else if and .WalletLookupHash (gt (len .WalletLookupResults) 0)}}
					<p class="text-sm" style="margin-top:10px; color:#b3bbd4;">
						Showing active workers for wallet hash <span class="mono sensitive-data">{{shortID .WalletLookupHash}}</span>.
					</p>
				{{end}}
				{{if gt (len .WalletLookupResults) 0}}
					<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-top:10px;">
						<div class="text-sm" style="color:var(--text-muted);">
							{{len .WalletLookupResults}} {{if gt (len .WalletLookupResults) 1}}miners{{else}}miner{{end}} found.
						</div>
						<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
							{{if gt .WalletLookupUnsavedCount 0}}
								<button id="walletLookupAddAll" class="btn btn-highlight" type="button" aria-label="Add all miners from this wallet">
									Add all ({{.WalletLookupUnsavedCount}})
								</button>
							{{else}}
								<button class="btn btn-secondary" type="button" disabled>All results saved</button>
							{{end}}
						</div>
					</div>
					<p class="text-sm" style="color:var(--text-muted); margin-top:6px;">
						Add actions skip workers that are already saved to prevent duplicates.
					</p>
					<div style="overflow-x:auto; margin-top:12px;">
						<table class="table">
							<thead>
								<tr>
									<th>Worker</th>
									<th>Hashrate</th>
									<th></th>
								</tr>
							</thead>
							<tbody>
								{{range .WalletLookupResults}}
									<tr>
										<td>
											<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
												<a class="mono worker-link" href="/worker/sha256?hash={{.WorkerSHA256}}">
													{{if .DisplayName}}{{.DisplayName}}{{else if .WorkerSHA256}}{{shortID .WorkerSHA256}}{{else}}Worker{{end}}
												</a>
											</div>
										</td>
										<td>{{if gt .RollingHashrate 0.0}}{{formatHashrate .RollingHashrate}}{{else}}â€”{{end}}</td>
										<td style="text-align:right;">
											{{if .AlreadySaved}}
												<span class="badge" style="display:inline-flex; gap:4px;">Saved</span>
											{{else}}
												<button type="button" class="btn btn-secondary wallet-lookup-add" data-worker="{{.Name}}" data-worker-hash="{{.WorkerSHA256}}" aria-label="Save {{.Name}} to saved workers">
													Add
												</button>
											{{end}}
										</td>
									</tr>
								{{end}}
							</tbody>
						</table>
					</div>
				{{end}}
			</div>

			<div class="card">
				<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
					<h2 style="margin-top:0;">Options</h2>
				</div>
				<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px;">
					<button id="privacyToggleNames" class="btn btn-secondary" type="button" aria-label="Toggle privacy" style="gap:8px;">
						<span id="privacyToggleIcon" aria-hidden="true">
							<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
								<path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7-10-7-10-7Z"></path>
								<circle cx="12" cy="12" r="3"></circle>
								<line x1="4" y1="20" x2="20" y2="4"></line>
							</svg>
						</span>
						<span id="privacyToggleText">Privacy</span>
					</button>

					{{if .DiscordNotificationsEnabled}}
						<button
							id="notifyAllToggle"
							class="btn btn-secondary"
							type="button"
							{{if not .DiscordNotificationsRegistered}}disabled{{end}}
							data-enabled="{{if .DiscordNotificationsUserEnabled}}1{{else}}0{{end}}"
							aria-label="{{if .DiscordNotificationsRegistered}}{{if .DiscordNotificationsUserEnabled}}Disable notifications{{else}}Enable notifications{{end}}{{else}}Register first to manage notifications{{end}}"
							title="{{if .DiscordNotificationsRegistered}}{{if .DiscordNotificationsUserEnabled}}Disable notifications{{else}}Enable notifications{{end}}{{else}}Register first to manage notifications{{end}}"
						>{{if .DiscordNotificationsUserEnabled}}ðŸ”• Disable notifications{{else}}ðŸ”” Enable notifications{{end}}</button>
						<button id="oneTimeCodeGenerate" class="btn btn-highlight{{if .DiscordNotificationsRegistered}} no-glow{{end}}" type="button" aria-label="Connect Your Discord Account!">
							Connect Your Discord Account!
						</button>
					{{end}}
					<a class="btn btn-secondary" href="/logout?redirect=/worker" aria-label="Sign out" style="gap:8px;">
						<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
							<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
							<polyline points="16 17 21 12 16 7"></polyline>
							<line x1="21" y1="12" x2="9" y2="12"></line>
						</svg>
						<span>Sign out</span>
					</a>
				</div>
			</div>
		</div>
		{{else}}
		<div class="card">
			<h2>Saved workers</h2>
			<p class="text-sm">Sign in to save workers for quick access.</p>
			<a class="btn" href="/sign-in?redirect=/saved-workers">Sign in</a>
		</div>
		{{end}}

	{{template "footer" .}}
	</main>
	{{if .DiscordNotificationsEnabled}}
	<dialog id="discordNotifDialog" class="discord-dialog" aria-label="Discord notifications setup">
		<div class="discord-dialog-header">
			<div style="display:flex; flex-direction:column; gap:2px;">
			<div style="font-weight:700;">Connect your Discord account</div>
			<div class="text-sm" style="color:var(--text-muted);">Get pinged when your saved workers go offline/online or find a block.</div>
		</div>
			<button id="discordNotifClose" class="btn btn-secondary" type="button" aria-label="Close">Close</button>
		</div>
		<div class="discord-dialog-body">
			<div class="text-sm" style="color:var(--text-muted);">
				<ol style="margin:0; padding-left:18px;">
					<li>Generate a one-time code</li>
					<li>In Discord, run <span class="mono">/notify</span> and paste the code</li>
				</ol>
			</div>

			<div class="discord-dialog-code">
				<span id="discordNotifCode" class="mono" style="display:none;" title="Click to copy"></span>
				<button id="discordNotifCopy" class="btn btn-secondary" type="button" style="display:none;">Copy</button>
				<button id="discordNotifRegenerate" class="btn btn-highlight" type="button">Generate code</button>
			</div>

			<div class="discord-dialog-actions">
				<button id="discordInviteBtn" class="btn" type="button" data-discord-url="{{.DiscordURL}}">Open Discord invite</button>
				<a class="btn btn-secondary" href="https://support-apps.discord.com/hc/en-us/articles/26501837786775-Slash-Commands-FAQ" target="_blank" rel="noopener noreferrer">How to use slash commands</a>
			</div>

			<div class="text-sm" style="margin-top:12px;">
				<span id="discordNotifStatus" class="badge" style="display:none;"></span>
				<span id="discordNotifExpires" class="badge" style="display:none;"></span>
			</div>

			<div class="text-sm" style="margin-top:10px; color:var(--text-muted);">
				Closing this dialog clears the code on the server. Codes expire after 5 minutes if unused.
			</div>
		</div>
	</dialog>
	{{end}}
	{{if .ClerkUser}}
	{{template "hashrate_graph_script" .}}
	<script src="/sha256.js"></script>
	<script>
	(function() {
		let hideWorkerNames = true;
		const discordNotificationsEnabled = {{if .DiscordNotificationsEnabled}}true{{else}}false{{end}};
		const clerkEnabled = {{if .ClerkEnabled}}true{{else}}false{{end}};
		const clerkPublishableKey = "{{.ClerkPublishableKey}}";
		const clerkJSURL = "{{.ClerkJSURL}}";
		const clerkLoginURL = "{{.ClerkLoginURL}}";

		let clerkLoadPromise = null;
		let clerkRefreshing = null;

		function redirectToLogin() {
			const url = (clerkLoginURL || '/sign-in?redirect=/saved-workers');
			try { window.location.href = url; } catch (_) {}
		}

		function loadClerkJS() {
			if (!clerkEnabled || !clerkPublishableKey || !clerkJSURL) return Promise.resolve(null);
			if (window.Clerk) return Promise.resolve(window.Clerk);
			if (clerkLoadPromise) return clerkLoadPromise;
			clerkLoadPromise = new Promise((resolve) => {
				const script = document.createElement('script');
				script.async = true;
				script.crossOrigin = 'anonymous';
				script.src = clerkJSURL;
				script.setAttribute('data-clerk-publishable-key', clerkPublishableKey);
				script.onload = () => resolve(window.Clerk || null);
				script.onerror = () => resolve(null);
				document.head.appendChild(script);
			}).then(async (clerk) => {
				try {
					if (clerk && typeof clerk.load === 'function') {
						await clerk.load();
					}
				} catch (_) {}
				return window.Clerk || clerk || null;
			});
			return clerkLoadPromise;
		}

		async function refreshClerkSession() {
			if (!clerkEnabled) return false;
			if (clerkRefreshing) return clerkRefreshing;
			clerkRefreshing = (async () => {
				const clerk = await loadClerkJS();
				if (!clerk) return false;
				try {
					if (clerk.session && typeof clerk.session.getToken === 'function') {
						const token = await clerk.session.getToken();
						if (!token) return false;
						const res = await fetch('/api/auth/session-refresh', {
							method: 'POST',
							credentials: 'same-origin',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ token }),
						});
						return res && res.ok;
					}
				} catch (_) {}
				return false;
			})().finally(() => {
				clerkRefreshing = null;
			});
			return clerkRefreshing;
		}

		async function fetchWithAuthRefresh(url, options) {
			const res = await fetch(url, options);
			if (res.status !== 401) return res;
			const ok = await refreshClerkSession();
			if (ok) {
				const retry = await fetch(url, options);
				if (retry.status !== 401) return retry;
			}
			redirectToLogin();
			return res;
		}

		const walletLookupForm = document.getElementById('walletLookupForm');
		const walletLookupInput = document.getElementById('walletLookupInput');
		const walletLookupHashInput = document.getElementById('walletLookupHash');
		const walletLookupAddAllButton = document.getElementById('walletLookupAddAll');

		function isSHA256Hex(str) {
			return /^[a-f0-9]{64}$/i.test((str || '').trim());
		}

		async function sha256Always(str) {
			if (typeof window.sha256Hex !== 'function') return null;
			try { return await window.sha256Hex(str); } catch (_) { return null; }
		}

		if (walletLookupForm) {
			walletLookupForm.addEventListener('submit', async function(event) {
				event.preventDefault();
				const walletAddress = (walletLookupInput?.value || '').trim();
				if (!walletAddress) {
					alert('Please enter a wallet address or wallet hash');
					return;
				}
				try {
					walletLookupInput.setAttribute('name', 'wallet');
					if (walletLookupHashInput) {
						walletLookupHashInput.value = '';
					}

					if (walletLookupHashInput && isSHA256Hex(walletAddress)) {
						walletLookupHashInput.value = walletAddress.toLowerCase();
						walletLookupInput.removeAttribute('name');
						this.submit();
						return;
					}

					const hash = await sha256Always(walletAddress);
					if (walletLookupHashInput && hash) {
						walletLookupHashInput.value = hash;
						walletLookupInput.removeAttribute('name');
					}
					this.submit();
				} catch (error) {
					console.error('Wallet lookup submit error:', error);
					this.submit();
				}
			});
		}

			async function saveWorkerFromLookup(workerName, button) {
				if (!workerName) {
					return false;
				}
				if (button) {
					button.disabled = true;
				}
				try {
					const payload = new URLSearchParams();
					payload.append('worker', workerName);
					const res = await fetchWithAuthRefresh('/worker/save', {
						method: 'POST',
						credentials: 'same-origin',
						body: payload.toString(),
						headers: {
							'Content-Type': 'application/x-www-form-urlencoded',
						},
					});
				if (!res.ok) {
					throw new Error('Failed to add worker');
				}
				if (button) {
					button.textContent = 'Saved';
					button.classList.remove('wallet-lookup-add');
					button.dataset.saved = '1';
					button.setAttribute('aria-label', 'Worker saved');
					button.disabled = true;
				}
				await refreshSavedWorkers();
				return true;
			} catch (error) {
				console.error('Add worker from wallet lookup failed:', error);
				if (button) {
					button.disabled = false;
				}
				return false;
			}
		}

		function updateWalletLookupAddAllState() {
			if (!walletLookupAddAllButton) {
				return;
			}
			const remaining = Array.from(document.querySelectorAll('.wallet-lookup-add')).filter((btn) => !btn.disabled);
			if (remaining.length === 0) {
				walletLookupAddAllButton.disabled = true;
				walletLookupAddAllButton.textContent = 'All results saved';
				return;
			}
			walletLookupAddAllButton.disabled = false;
			walletLookupAddAllButton.textContent = `Add all (${remaining.length})`;
		}

		function attachWalletLookupAddHandlers() {
			const buttons = document.querySelectorAll('.wallet-lookup-add');
			buttons.forEach((btn) => {
				if (btn.__walletLookupAttached) {
					return;
				}
				btn.__walletLookupAttached = true;
				btn.addEventListener('click', async () => {
					const worker = btn.getAttribute('data-worker') || '';
					await saveWorkerFromLookup(worker, btn);
					updateWalletLookupAddAllState();
				});
			});
		}

		if (walletLookupAddAllButton) {
			walletLookupAddAllButton.addEventListener('click', async () => {
				const buttons = Array.from(document.querySelectorAll('.wallet-lookup-add')).filter((btn) => !btn.disabled);
				if (buttons.length === 0) {
					return;
				}
				walletLookupAddAllButton.disabled = true;
				for (const btn of buttons) {
					const worker = btn.getAttribute('data-worker') || '';
					await saveWorkerFromLookup(worker, btn);
				}
				updateWalletLookupAddAllState();
			});
		}

		// One-time code (server-generated, stored in memory for 5 minutes).
		const oneTimeCodeGenerateBtn = document.getElementById('oneTimeCodeGenerate');
		const discordDialog = document.getElementById('discordNotifDialog');
		const discordDialogClose = document.getElementById('discordNotifClose');
		const discordCodeEl = document.getElementById('discordNotifCode');
		const discordCopyBtn = document.getElementById('discordNotifCopy');
		const discordRegenBtn = document.getElementById('discordNotifRegenerate');
		const discordInviteBtn = document.getElementById('discordInviteBtn');
		const discordStatusEl = document.getElementById('discordNotifStatus');
		const discordExpiresEl = document.getElementById('discordNotifExpires');
		let oneTimeCodeTimeout = null;
		let oneTimeCodeCountdownTimer = null;
		let activeOneTimeCode = '';
		let activeExpiresAtMillis = 0;

		function setBadge(el, text, danger) {
			if (!el) return;
			text = String(text || '');
			if (danger) el.classList.add('badge-danger');
			else el.classList.remove('badge-danger');
			if (text) {
				el.textContent = text;
				el.style.display = '';
			} else {
				el.style.display = 'none';
			}
		}

		const onlineWorkersBody = document.getElementById('onlineWorkersBody');
		const onlineWorkersCard = document.getElementById('onlineWorkersCard');
		const sortFieldSelect = document.getElementById('savedWorkersSortField');
		const sortOrderBtn = document.getElementById('savedWorkersSortOrder');
		let lastOnlineWorkers = [];
		let currentSortField = 'connection_seq';
		let sortDescending = true;
		const workerHashrateFallbackMaxAgeMS = 2 * 60 * 1000;
		const workerHashrateFallback = new Map();
		const workerShareRateFallbackMaxAgeMS = 2 * 60 * 1000;
		const workerShareRateFallback = new Map();

		function workerHashrateKey(worker) {
			const hash = String(worker?.hash || '').trim().toLowerCase();
			if (hash) {
				return `hash:${hash}`;
			}
			const connectionSeq = Number(worker?.connection_seq || 0);
			if (connectionSeq > 0) {
				return `connseq:${connectionSeq}`;
			}
			const name = String(worker?.name || '').trim();
			if (name) {
				return `name:${name}`;
			}
			return '';
		}

		function pruneWorkerHashrateFallback(nowMillis) {
			for (const [key, sample] of workerHashrateFallback.entries()) {
				if (!sample || !Number.isFinite(sample.value) || sample.value <= 0 || !Number.isFinite(sample.at) || nowMillis-sample.at > workerHashrateFallbackMaxAgeMS) {
					workerHashrateFallback.delete(key);
				}
			}
		}

		function pruneWorkerShareRateFallback(nowMillis) {
			for (const [key, sample] of workerShareRateFallback.entries()) {
				if (!sample || !Number.isFinite(sample.value) || sample.value <= 0 || !Number.isFinite(sample.at) || nowMillis-sample.at > workerShareRateFallbackMaxAgeMS) {
					workerShareRateFallback.delete(key);
				}
			}
		}

		function effectiveWorkerHashrate(worker, nowMillis) {
			const key = workerHashrateKey(worker);
			const raw = Number(worker?.hashrate || 0);
			if (Number.isFinite(raw) && raw > 0) {
				if (key) {
					workerHashrateFallback.set(key, { value: raw, at: nowMillis });
				}
				return raw;
			}
			if (key) {
				const sample = workerHashrateFallback.get(key);
				if (sample && Number.isFinite(sample.value) && sample.value > 0 && Number.isFinite(sample.at) && nowMillis-sample.at <= workerHashrateFallbackMaxAgeMS) {
					return sample.value;
				}
			}
			return 0;
		}

		function effectiveWorkerShareRate(worker, nowMillis) {
			const key = workerHashrateKey(worker);
			const raw = Number(worker?.shares_per_minute || 0);
			if (Number.isFinite(raw) && raw > 0) {
				if (key) {
					workerShareRateFallback.set(key, { value: raw, at: nowMillis });
				}
				return raw;
			}
			if (key) {
				const sample = workerShareRateFallback.get(key);
				if (sample && Number.isFinite(sample.value) && sample.value > 0 && Number.isFinite(sample.at) && nowMillis-sample.at <= workerShareRateFallbackMaxAgeMS) {
					return sample.value;
				}
			}
			return 0;
		}

		function notifyToggleText(enabled) {
			return enabled ? 'ðŸ””' : 'ðŸ”•';
		}

		function notifyToggleTitle(enabled) {
			return enabled ? 'Disable pings for this worker' : 'Enable pings for this worker';
		}

		function notifyAllToggleText(enabled) {
			return enabled ? 'ðŸ”• Disable notifications' : 'ðŸ”” Enable notifications';
		}

		function notifyAllToggleTitle(enabled) {
			return enabled ? 'Disable notifications' : 'Enable notifications';
		}

		function formatHashrate(value) {
			if (!value || value <= 0) {
				return 'â€”';
			}
			const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
			let val = value;
			let idx = 0;
			while (val >= 1000 && idx < units.length - 1) {
				val /= 1000;
				idx++;
			}
			return `${val.toFixed(2)} ${units[idx]}`;
		}

		function formatWorkerHashrate(value, accuracy) {
			const base = formatHashrate(value);
			if (base === 'â€”' || base === '---') return 'â€”';
			let marker = String(accuracy || '').trim();
			if (marker === 'â‰ˆ+' || marker === 'âœ“') marker = '';
			return marker ? `${marker} ${base}` : base;
		}

		function hashrateClassForAccuracy(accuracy) {
			const marker = String(accuracy || '').trim();
			if (marker === '~') return 'hashrate-warming';
			if (marker === 'â‰ˆ') return 'hashrate-settling';
			if (marker === 'â‰ˆ+' || marker === 'âœ“' || marker === '') return 'hashrate-solid';
			return '';
		}

		function formatShareRate(rate) {
			const value = Number(rate || 0);
			if (!value) return '0';
			if (value < 1000) return value.toFixed(1);
			if (value < 1000000) return (value / 1000).toFixed(1) + 'K';
			if (value < 1000000000) return (value / 1000000).toFixed(1) + 'M';
			return (value / 1000000000).toFixed(1) + 'B';
		}

			function formatDifficulty(diff) {
				const value = Number(diff || 0);
				if (!value || value <= 0) return 'â€”';
			if (value < 1000000) return value.toFixed(0);
			if (value >= 1000000000000000) return (value / 1000000000000000).toFixed(1) + 'P';
			if (value >= 1000000000000) return (value / 1000000000000).toFixed(1) + 'T';
			if (value >= 1000000000) return (value / 1000000000).toFixed(1) + 'G';
			return (value / 1000000).toFixed(1) + 'M';
			}

			function formatLastShare(value) {
				if (!value) return 'â€”';
				const ts = Date.parse(value);
				if (!isFinite(ts) || ts <= 0) return 'â€”';
				const seconds = Math.floor((Date.now() - ts) / 1000);
				if (seconds < 60) return 'Just now';
				return formatTimeAgo(seconds);
			}

		function formatDuration(seconds) {
			const total = Math.max(0, Math.floor(seconds || 0));
			const hours = Math.floor(total / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;
			if (hours > 0) return `${hours}h ${minutes}m`;
			if (minutes > 0) return `${minutes}m ${secs}s`;
			return `${secs}s`;
		}

		function formatLatency(ms) {
			const v = Number(ms || 0);
			if (!isFinite(v) || v <= 0) return 'â€”';
			if (v < 1) return `${Math.max(1, Math.round(v * 1000))}us`;
			if (v < 1000) return `${Math.round(v)}ms`;
			const sec = v / 1000;
			if (sec < 60) return `${sec.toFixed(1)}s`;
			const min = sec / 60;
			return `${min.toFixed(1)}m`;
		}

		function formatLatencyPair(p50, p95) {
			const a = Number(p50 || 0);
			const b = Number(p95 || 0);
			if (!isFinite(a) || !isFinite(b) || b <= 0) return 'â€”';
			if (a < 1 && b < 1) return `${Math.max(1, Math.round(a * 1000))}/${Math.max(1, Math.round(b * 1000))}us`;
			if (a < 1000 && b < 1000) return `${Math.round(a)}/${Math.round(b)}ms`;
			const aSec = a / 1000;
			const bSec = b / 1000;
			if (aSec < 60 && bSec < 60) return `${aSec.toFixed(1)}/${bSec.toFixed(1)}s`;
			const aMin = aSec / 60;
			const bMin = bSec / 60;
			return `${aMin.toFixed(1)}/${bMin.toFixed(1)}m`;
		}

		function formatWorkStartLatency(row) {
			const min = Number(row.notify_to_first_share_min_ms || 0);
			const p50 = Number(row.notify_to_first_share_p50_ms || 0);
			const last = Number(row.notify_to_first_share_ms || 0);
			if (min > 0) return formatLatency(min);
			return formatLatency(p50 > 0 ? p50 : last);
		}

		function formatTimeAgo(seconds) {
			const total = Math.max(0, Math.floor(seconds || 0));
			const days = Math.floor(total / 86400);
			const hours = Math.floor((total % 86400) / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			if (days > 0) return `${days}d ${hours}h ago`;
			if (hours > 0) return `${hours}h ${minutes}m ago`;
			return `${Math.max(0, minutes)}m ago`;
		}

		function renderStoredHashrates() {
			const cells = document.querySelectorAll('[data-hashrate]');
			cells.forEach((el) => {
				const value = Number(el.getAttribute('data-hashrate'));
				const accuracy = el.getAttribute('data-hashrate-accuracy');
				el.classList.remove('hashrate-warming', 'hashrate-settling', 'hashrate-solid');
				if (!value) {
					el.textContent = 'â€”';
					return;
				}
				const cls = hashrateClassForAccuracy(accuracy);
				if (cls) el.classList.add(cls);
				el.textContent = formatWorkerHashrate(value, accuracy);
			});
		}

		function renderStoredLatencies() {
			const pairCells = document.querySelectorAll('.latency-pair[data-rtt-p95-ms]');
			pairCells.forEach((el) => {
				const p50 = Number(el.getAttribute('data-rtt-p50-ms') || 0);
				const p95 = Number(el.getAttribute('data-rtt-p95-ms') || 0);
				el.textContent = formatLatency(p50 > 0 ? p50 : p95);
			});
			const singleCells = document.querySelectorAll('.latency-single[data-latency-ms]');
			singleCells.forEach((el) => {
				el.textContent = formatLatency(el.getAttribute('data-latency-ms'));
			});
			const workPairCells = document.querySelectorAll('.latency-pair-work[data-work-p95-ms]');
				workPairCells.forEach((el) => {
					const min = Number(el.getAttribute('data-work-min-ms') || 0);
					const p50 = Number(el.getAttribute('data-work-p50-ms') || 0);
					const last = Number(el.getAttribute('data-work-last-ms') || 0);
				if (min > 0) {
					el.textContent = formatLatency(min);
					return;
				}
				el.textContent = formatLatency(p50 > 0 ? p50 : last);
			});
		}

		function updateSortOrderButtonText() {
			if (!sortOrderBtn) return;
			sortOrderBtn.textContent = sortDescending ? 'Desc â†“' : 'Asc â†‘';
		}

		function censorString(s) {
			if (!s || s.length <= 16) return s;
			if (s.startsWith('..')) {
				s = s.substring(2).trim();
			}
			return s.substring(0, 8) + '..' + s.substring(s.length - 8);
		}

		function applyWorkerNameCensoring(root) {
			const scope = root || document;
			const workers = scope.querySelectorAll('.sensitive-worker');
			workers.forEach((el) => {
				const name = el.getAttribute('data-worker-name') || '';
				const hash = el.getAttribute('data-worker-hash') || '';
				const raw = name || hash || 'Unknown';
				let display = '';
				if (hideWorkerNames) {
					display = censorString(raw) || 'Hidden';
				} else {
					display = raw;
				}
				el.textContent = display;
				el.title = display;
			});
		}

		function applyLastOnlineLabels(root) {
			const scope = root || document;
			const labels = scope.querySelectorAll('.offline-last-online');
			labels.forEach((el) => {
				const raw = el.getAttribute('data-last-online-at') || '';
				const ts = Date.parse(raw);
				if (!isFinite(ts)) {
					el.textContent = '';
					return;
				}
				const seconds = (Date.now() - ts) / 1000;
				el.textContent = `Last online ${formatTimeAgo(seconds)}`;
			});
		}

		function attachRemoveConfirms(root) {
			const scope = root || document;
			const forms = scope.querySelectorAll('form[data-remove-worker]');
			forms.forEach((form) => {
				if (form.__removeConfirmAttached) return;
				form.__removeConfirmAttached = true;
				form.addEventListener('submit', (e) => {
					const name = form.getAttribute('data-remove-worker') || 'this worker';
					if (!confirm(`Remove ${name}?`)) {
						e.preventDefault();
					}
				});
			});
		}

		function attachReconnectConfirms(root) {
			const scope = root || document;
			const forms = scope.querySelectorAll('form[data-reconnect-worker]');
			forms.forEach((form) => {
				if (form.__reconnectConfirmAttached) return;
				form.__reconnectConfirmAttached = true;
				form.addEventListener('submit', (e) => {
					const name = form.getAttribute('data-reconnect-worker') || 'this worker';
					if (!confirm(`Force reset ${name}? This applies a 30s ban, then disconnects active sessions.`)) {
						e.preventDefault();
					}
				});
			});
		}

		function attachNotifyToggles(root) {
			const scope = root || document;
			const toggles = scope.querySelectorAll('.worker-notify-toggle');
			toggles.forEach((btn) => {
				if (btn.__notifyToggleAttached) return;
				btn.__notifyToggleAttached = true;
				btn.addEventListener('click', async () => {
					const hash = btn.getAttribute('data-worker-hash') || '';
					if (!hash) return;
					const current = btn.getAttribute('data-notify-enabled') === '1';
					const next = !current;
					btn.disabled = true;
					try {
						const res = await fetchWithAuthRefresh('/api/saved-workers/notify-enabled', {
							method: 'POST',
							credentials: 'same-origin',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ hash, enabled: next }),
						});
						if (!res.ok) return;
						const data = await res.json();
						const enabled = !!data.enabled;
						btn.setAttribute('data-notify-enabled', enabled ? '1' : '0');
						btn.textContent = notifyToggleText(enabled);
						btn.title = notifyToggleTitle(enabled);
						btn.setAttribute('aria-label', notifyToggleTitle(enabled));
					} catch (_) {
					} finally {
						btn.disabled = false;
					}
				});
			});
		}

		function attachNotifyAllButtons() {
			const btn = document.getElementById('notifyAllToggle');
			if (!btn || btn.__notifyAllAttached) return;
			btn.__notifyAllAttached = true;
			btn.addEventListener('click', async () => {
				const current = btn.getAttribute('data-enabled') === '1';
				const next = !current;
				btn.disabled = true;
				try {
					const res = await fetchWithAuthRefresh('/api/discord/notify-enabled', {
						method: 'POST',
						credentials: 'same-origin',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ enabled: next }),
					});
					if (!res.ok) return;
					const data = await res.json();
					const enabled = !!data.enabled;
					btn.setAttribute('data-enabled', enabled ? '1' : '0');
					btn.textContent = notifyAllToggleText(enabled);
					btn.title = notifyAllToggleTitle(enabled);
					btn.setAttribute('aria-label', notifyAllToggleTitle(enabled));
				} catch (_) {
				} finally {
					btn.disabled = false;
				}
			});
		}

		function renderOnlineWorkers(workers) {
			lastOnlineWorkers = Array.isArray(workers) ? workers.slice() : [];
			if (!onlineWorkersBody) return;
			const data = lastOnlineWorkers.slice();
			data.sort((a, b) => {
				let va;
				let vb;
				if (currentSortField === 'name') {
					va = String(a.name || '').toLowerCase();
					vb = String(b.name || '').toLowerCase();
				} else if (currentSortField === 'hashrate') {
					va = Number(a.hashrate || 0);
					vb = Number(b.hashrate || 0);
				} else {
					va = Number(a.connection_seq || 0);
					vb = Number(b.connection_seq || 0);
				}
				if (va < vb) return sortDescending ? 1 : -1;
				if (va > vb) return sortDescending ? -1 : 1;
				return 0;
			});

			if (data.length === 0) {
				if (onlineWorkersCard) onlineWorkersCard.style.display = 'none';
				onlineWorkersBody.innerHTML = '<tr><td colspan="12" class="text-sm">No saved workers online right now.</td></tr>';
				return;
			}
			const nowMillis = Date.now();
			pruneWorkerHashrateFallback(nowMillis);
			pruneWorkerShareRateFallback(nowMillis);
			if (onlineWorkersCard) onlineWorkersCard.style.display = '';
			onlineWorkersBody.innerHTML = data.map((w) => {
				const hashrate = effectiveWorkerHashrate(w, nowMillis);
				const shareRate = effectiveWorkerShareRate(w, nowMillis);
				const hashrateClass = hashrate > 0 ? hashrateClassForAccuracy(w.hashrate_accuracy) : '';
				const hashrateText = hashrate > 0 ? formatWorkerHashrate(hashrate, w.hashrate_accuracy) : 'â€”';
				return `
					<tr>
						<td><a class="mono sensitive-worker worker-link" data-worker-name="${escapeAttr(w.name || '')}" data-worker-hash="${escapeAttr(w.hash || '')}" href="/worker/sha256?hash=${escapeAttr(w.hash || '')}"></a></td>
						<td class="hashrate-value ${hashrateClass}">${hashrateText}</td>
						<td>${formatDifficulty(w.best_difficulty)}</td>
						<td>${formatDifficulty(w.difficulty)}</td>
					<td>${formatShareRate(shareRate)}</td>
					<td>${formatLastShare(w.last_share)}</td>
					<td>${Number(w.accepted || 0).toLocaleString()}</td>
					<td>${Number(w.rejected || 0).toLocaleString()}</td>
						<td>${formatLatency((Number(w.estimated_ping_p50_ms || 0) > 0) ? w.estimated_ping_p50_ms : w.estimated_ping_p95_ms)}</td>
					<td>${formatWorkStartLatency(w)}</td>
					<td>${formatDuration(w.connection_duration_seconds)}</td>
					<td style="text-align:right;">
						<div style="display:flex; gap:8px; justify-content:flex-end; align-items:center;">
							${discordNotificationsEnabled ? `<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="${escapeAttr(w.hash || '')}" data-notify-enabled="${w.notify_enabled ? '1' : '0'}" title="${escapeAttr(notifyToggleTitle(!!w.notify_enabled))}" aria-label="${escapeAttr(notifyToggleTitle(!!w.notify_enabled))}">${escapeHTML(notifyToggleText(!!w.notify_enabled))}</button>` : ''}
								<form method="post" action="/worker/reconnect" style="margin:0;" data-reconnect-worker="${escapeAttr(w.name || '')}">
									<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
									<button class="btn btn-secondary" type="submit" aria-label="Force reset worker" title="Force reset (30s ban + disconnect)">Force reset</button>
								</form>
							<form method="post" action="/worker/remove" style="margin:0;" data-remove-worker="${escapeAttr(w.name || '')}">
								<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
								<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
									<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
										<polyline points="3 6 5 6 21 6"></polyline>
										<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
										<path d="M10 11v6"></path>
										<path d="M14 11v6"></path>
										<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
									</svg>
								</button>
							</form>
						</div>
					</td>
				</tr>
			`;
			}).join('');
			applyWorkerNameCensoring(onlineWorkersBody);
			attachRemoveConfirms(onlineWorkersBody);
			attachReconnectConfirms(onlineWorkersBody);
			attachNotifyToggles(onlineWorkersBody);
		}

		async function copyTextToClipboard(text) {
			const clip = navigator.clipboard;
			if (clip && clip.writeText) {
				await clip.writeText(text);
				return true;
			}
			const ta = document.createElement('textarea');
			ta.value = text;
			ta.setAttribute('readonly', '');
			ta.style.position = 'fixed';
			ta.style.top = '-9999px';
			ta.style.left = '-9999px';
			document.body.appendChild(ta);
			ta.select();
			try {
				return document.execCommand('copy');
			} finally {
				document.body.removeChild(ta);
			}
		}

		async function clearOneTimeCodeServerSide() {
			const code = activeOneTimeCode;
			if (!code) return;
			try {
				await fetchWithAuthRefresh('/api/saved-workers/one-time-code/clear', {
					method: 'POST',
					credentials: 'same-origin',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ code }),
				});
			} catch (_) {
				// ignore
			}
		}

		function clearOneTimeCodeUI(statusText) {
			activeOneTimeCode = '';
			activeExpiresAtMillis = 0;
			if (oneTimeCodeTimeout) {
				clearTimeout(oneTimeCodeTimeout);
				oneTimeCodeTimeout = null;
			}
			if (oneTimeCodeCountdownTimer) {
				clearInterval(oneTimeCodeCountdownTimer);
				oneTimeCodeCountdownTimer = null;
			}
			if (discordCodeEl) discordCodeEl.style.display = 'none';
			if (discordCopyBtn) discordCopyBtn.style.display = 'none';
			if (statusText === 'Expired') {
				setBadge(discordStatusEl, 'Code expired, generate a new one.', true);
				setBadge(discordExpiresEl, 'Expired', true);
			} else {
				setBadge(discordStatusEl, statusText || '', false);
				setBadge(discordExpiresEl, '', false);
			}
		}

		function updateExpiresCountdown() {
			if (!activeOneTimeCode || !activeExpiresAtMillis) {
				setBadge(discordExpiresEl, '', false);
				return;
			}
			const seconds = Math.max(0, Math.ceil((activeExpiresAtMillis - Date.now()) / 1000));
			setBadge(discordExpiresEl, `Expires in ${seconds}s`, false);
			if (seconds <= 0) {
				clearOneTimeCodeUI('Expired');
			}
		}

		function setOneTimeCode(code, expiresAtMillis) {
			activeOneTimeCode = code || '';
			activeExpiresAtMillis = Number(expiresAtMillis) || 0;
			if (discordCodeEl) {
				discordCodeEl.textContent = activeOneTimeCode;
				discordCodeEl.style.display = activeOneTimeCode ? '' : 'none';
			}
			if (discordCopyBtn) discordCopyBtn.style.display = activeOneTimeCode ? '' : 'none';
			setBadge(discordStatusEl, activeOneTimeCode ? 'Copy the code, then run /notify in Discord.' : '', false);
			updateExpiresCountdown();
			if (oneTimeCodeTimeout) clearTimeout(oneTimeCodeTimeout);
			if (oneTimeCodeCountdownTimer) {
				clearInterval(oneTimeCodeCountdownTimer);
				oneTimeCodeCountdownTimer = null;
			}
			if (activeOneTimeCode && expiresAtMillis) {
				const remaining = Math.max(0, expiresAtMillis - Date.now());
				oneTimeCodeTimeout = setTimeout(() => clearOneTimeCodeUI('Expired'), remaining);
				oneTimeCodeCountdownTimer = setInterval(updateExpiresCountdown, 250);
			}
		}

		async function generateOneTimeCode() {
			setBadge(discordStatusEl, 'Generating...', false);
			setBadge(discordExpiresEl, '', false);
			try {
				if (discordRegenBtn) discordRegenBtn.disabled = true;
				if (oneTimeCodeGenerateBtn) oneTimeCodeGenerateBtn.disabled = true;
				const res = await fetchWithAuthRefresh('/api/saved-workers/one-time-code', {
					method: 'POST',
					credentials: 'same-origin',
					headers: { 'Content-Type': 'application/json' },
					body: '{}',
				});
				if (!res.ok) throw new Error('request failed');
				const data = await res.json();
				const code = String(data.code || '');
				const expiresAt = Date.parse(String(data.expires_at || ''));
				if (!code || !isFinite(expiresAt)) throw new Error('bad response');
				setOneTimeCode(code, expiresAt);
			} catch (_) {
				clearOneTimeCodeUI('Error');
			} finally {
				if (discordRegenBtn) discordRegenBtn.disabled = false;
				if (oneTimeCodeGenerateBtn) oneTimeCodeGenerateBtn.disabled = false;
			}
		}

		function openDiscordDialog() {
			if (!discordDialog) return;
			clearOneTimeCodeUI('');
			try {
				if (typeof discordDialog.showModal === 'function') {
					discordDialog.showModal();
				} else {
					discordDialog.setAttribute('open', '');
				}
			} catch (_) {
				discordDialog.setAttribute('open', '');
			}
		}

		function closeDiscordDialog() {
			if (!discordDialog) return;
			try {
				discordDialog.close();
			} catch (_) {
				discordDialog.removeAttribute('open');
			}
		}

		function attachDiscordDialogHandlers() {
			if (oneTimeCodeGenerateBtn && !oneTimeCodeGenerateBtn.__discordDialogAttached) {
				oneTimeCodeGenerateBtn.__discordDialogAttached = true;
				oneTimeCodeGenerateBtn.addEventListener('click', async function() {
					openDiscordDialog();
					await generateOneTimeCode();
				});
			}

			if (discordRegenBtn && !discordRegenBtn.__discordDialogAttached) {
				discordRegenBtn.__discordDialogAttached = true;
				discordRegenBtn.addEventListener('click', async function() {
					await generateOneTimeCode();
				});
			}

			if (discordInviteBtn && !discordInviteBtn.__discordDialogAttached) {
				discordInviteBtn.__discordDialogAttached = true;
				const url = String(discordInviteBtn.getAttribute('data-discord-url') || '').trim();
				if (!url) {
					discordInviteBtn.disabled = true;
					discordInviteBtn.title = 'Discord invite link is not configured for this pool.';
				}
				discordInviteBtn.addEventListener('click', function() {
					const u = String(discordInviteBtn.getAttribute('data-discord-url') || '').trim();
					if (!u) {
						if (discordStatusEl) {
							discordStatusEl.textContent = 'Discord invite link is not configured for this pool.';
							discordStatusEl.style.display = '';
						}
						return;
					}
					window.open(u, '_blank', 'noopener,noreferrer');
				});
			}

			async function doCopy() {
				const code = activeOneTimeCode;
				if (!code) return;
				try {
					const ok = await copyTextToClipboard(code);
					if (!ok) throw new Error('copy failed');
					if (discordStatusEl) {
						discordStatusEl.textContent = 'Copied';
						discordStatusEl.style.display = '';
						setTimeout(() => {
							if (activeOneTimeCode) {
								discordStatusEl.textContent = 'Copy the code, then run /notify in Discord.';
							}
						}, 1200);
					}
				} catch (_) {
					prompt('Copy one-time code:', code);
				}
			}

			if (discordCopyBtn && !discordCopyBtn.__discordDialogAttached) {
				discordCopyBtn.__discordDialogAttached = true;
				discordCopyBtn.addEventListener('click', doCopy);
			}
			if (discordCodeEl && !discordCodeEl.__discordDialogAttached) {
				discordCodeEl.__discordDialogAttached = true;
				discordCodeEl.addEventListener('click', doCopy);
			}

			if (discordDialogClose && !discordDialogClose.__discordDialogAttached) {
				discordDialogClose.__discordDialogAttached = true;
				discordDialogClose.addEventListener('click', async function() {
					await clearOneTimeCodeServerSide();
					clearOneTimeCodeUI('');
					closeDiscordDialog();
				});
			}

			if (discordDialog && !discordDialog.__discordDialogAttached) {
				discordDialog.__discordDialogAttached = true;

				// Click outside closes (native dialogs only).
				discordDialog.addEventListener('click', function(e) {
					if (e.target === discordDialog) {
						discordDialogClose && discordDialogClose.click();
					}
				});

				// Any close (Esc / programmatic) clears the code server-side.
				discordDialog.addEventListener('close', async function() {
					await clearOneTimeCodeServerSide();
					clearOneTimeCodeUI('');
				});
			}
		}

		function updatePrivacyToggle() {
			const btn = document.getElementById('privacyToggleNames');
			const text = document.getElementById('privacyToggleText');
			if (!btn || !text) return;
			text.textContent = hideWorkerNames ? 'Privacy: On' : 'Privacy: Off';
		}

		async function refreshSavedWorkers() {
			try {
				const res = await fetchWithAuthRefresh('/api/saved-workers', { credentials: 'same-origin' });
				if (!res.ok) return;
				const data = await res.json();
				const notifyAllToggle = document.getElementById('notifyAllToggle');
				if (notifyAllToggle && typeof data.discord_registered === 'boolean') {
					const registered = !!data.discord_registered;
					const enabled = !!data.discord_notify_enabled;
					notifyAllToggle.disabled = !registered;
					notifyAllToggle.setAttribute('data-enabled', enabled ? '1' : '0');
					notifyAllToggle.textContent = notifyAllToggleText(enabled);
					notifyAllToggle.title = registered ? notifyAllToggleTitle(enabled) : 'Register first to manage notifications';
				}
				const savedCount = document.getElementById('savedCount');
				const savedMax = document.getElementById('savedMax');
				const onlineCount = document.getElementById('onlineCount');
				if (savedCount) savedCount.textContent = data.saved_count ?? '';
				if (savedMax) savedMax.textContent = data.saved_max ?? '';
				if (onlineCount) onlineCount.textContent = data.online_count ?? '';
				const bestDiffEl = document.getElementById('savedBestDiffValue');
				if (bestDiffEl) {
					bestDiffEl.textContent = formatDifficulty(data.best_difficulty);
				}

				const online = Array.isArray(data.online_workers) ? data.online_workers : [];
				// Update total hashrate time series (sum of online worker hashrate).
				let totalHashrate = 0;
				for (const w of online) {
					totalHashrate += Number(w.hashrate || 0);
				}
				const safeHashrate = isFinite(totalHashrate) ? totalHashrate : 0;
				window.savedWorkersTotalHashrate = safeHashrate;
				if (window.updateHashrateGraph) {
					window.updateHashrateGraph(safeHashrate, null);
				}
				renderOnlineWorkers(online);

				const offlineList = document.getElementById('offlineWorkersList');
				const offlineSection = document.getElementById('offlineSection');
				const offlineEmptyMessage = document.getElementById('offlineEmptyMessage');
				const offlineCountBadge = document.getElementById('offlineCountBadge');
				if (offlineList && offlineSection && offlineEmptyMessage) {
					const offline = Array.isArray(data.offline_workers) ? data.offline_workers : [];
					if (offline.length === 0) {
						offlineList.innerHTML = '';
						offlineList.style.display = 'none';
						offlineEmptyMessage.style.display = 'none';
						offlineSection.style.display = 'none';
						if (offlineCountBadge) {
							offlineCountBadge.style.display = 'none';
						}
					} else {
						offlineSection.style.display = '';
						offlineEmptyMessage.style.display = 'none';
						offlineList.style.display = '';
						if (offlineCountBadge) {
							offlineCountBadge.style.display = '';
							offlineCountBadge.textContent = `${offline.length} offline`;
						}
						offlineList.innerHTML = offline.map(w => `
								<li>
									<div class="offline-worker-meta">
										<a class="mono sensitive-worker worker-link" data-worker-name="${escapeAttr(w.name || '')}" data-worker-hash="${escapeAttr(w.hash || '')}" href="/worker/sha256?hash=${escapeAttr(w.hash || '')}"></a>
										<span class="text-sm offline-last-online" data-last-online-at="${escapeAttr(w.last_online_at || '')}"></span>
										<span class="text-sm" style="color:var(--text-muted);">Best share: ${formatDifficulty(w.best_difficulty)}</span>
									</div>
								<span class="badge badge-danger">Offline</span>
								<div class="offline-actions" style="display:flex; gap:8px; justify-content:flex-end; align-items:center;">
									${discordNotificationsEnabled ? `<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="${escapeAttr(w.hash || '')}" data-notify-enabled="${w.notify_enabled ? '1' : '0'}" title="${escapeAttr(notifyToggleTitle(!!w.notify_enabled))}">${escapeHTML(notifyToggleText(!!w.notify_enabled))}</button>` : ''}
									<form method="post" action="/worker/remove" style="margin:0;" data-remove-worker="${escapeAttr(w.name || '')}">
										<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
										<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
											<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
												<polyline points="3 6 5 6 21 6"></polyline>
												<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
												<path d="M10 11v6"></path>
												<path d="M14 11v6"></path>
												<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
											</svg>
										</button>
									</form>
								</div>
							</li>
						`).join('');
						applyWorkerNameCensoring(offlineList);
						applyLastOnlineLabels(offlineList);
						attachRemoveConfirms(offlineList);
						attachNotifyToggles(offlineList);
					}
				}
			} catch (_) {}
		}

		function escapeHTML(str) {
			return String(str)
				.replaceAll('&', '&amp;')
				.replaceAll('<', '&lt;')
				.replaceAll('>', '&gt;')
				.replaceAll('"', '&quot;')
				.replaceAll("'", '&#39;');
		}

		function escapeAttr(str) {
			return escapeHTML(str);
		}

		attachRemoveConfirms(document);
		attachReconnectConfirms(document);
		applyWorkerNameCensoring(document);
		applyLastOnlineLabels(document);
		attachNotifyToggles(document);
		attachNotifyAllButtons();
		attachDiscordDialogHandlers();
		attachWalletLookupAddHandlers();
		updateWalletLookupAddAllState();
		updatePrivacyToggle();

		// Best-effort: keep the login cookie fresh while this page is open.
		if (clerkEnabled) {
			setInterval(() => { refreshClerkSession(); }, 60 * 1000);
		}

		const privacyToggle = document.getElementById('privacyToggleNames');
		if (privacyToggle) {
			privacyToggle.addEventListener('click', function() {
				hideWorkerNames = !hideWorkerNames;
				updatePrivacyToggle();
				applyWorkerNameCensoring(document);
			});
		}

		refreshSavedWorkers();
		setInterval(refreshSavedWorkers, 5000);
		updateSortOrderButtonText();
		if (sortFieldSelect) {
			sortFieldSelect.value = currentSortField;
		}
		if (sortFieldSelect) {
			sortFieldSelect.addEventListener('change', function() {
				currentSortField = sortFieldSelect.value || 'connection_seq';
				renderOnlineWorkers(lastOnlineWorkers);
			});
		}
		if (sortOrderBtn) {
			sortOrderBtn.addEventListener('click', function() {
				sortDescending = !sortDescending;
				updateSortOrderButtonText();
				renderOnlineWorkers(lastOnlineWorkers);
			});
		}
	})();
	</script>
	<script>
		(function() {
			const REFRESH_INTERVAL = 5000;
			const FIAT_CURRENCY = '{{.FiatCurrency}}';
			const OVERVIEW_CACHE_KEY = 'savedWorkers.overview.v1';
			const HASHRATE_CACHE_KEY = 'savedWorkers.hashrate.v1';
			const poolTagEl = document.getElementById('status-pool-tag');
		const valueEl = document.getElementById('status-pool-hashrate');
		const blockHeightEl = document.getElementById('status-block-height');
		const blockHeightContextEl = document.getElementById('status-block-height-context');
		const blockDifficultyEl = document.getElementById('status-block-difficulty');
		const networkHashrateEl = document.getElementById('status-network-hashrate');
		const blockChanceEl = document.getElementById('status-block-chance');
		const templateTxFeesEl = document.getElementById('status-template-tx-fees');
		const templateTxFeesUpdatedEl = document.getElementById('status-template-tx-fees-updated');
		const blockTimeLeftEl = document.getElementById('status-block-time-left');
		const blockHistoryEl = document.getElementById('status-block-history');

		let btcPriceFiat = 0;
		let fiatCurrency = 'USD';
		let blockTimeLeftSec = null;
		let blockTimeOverdueSec = 0;
		let isBlockTimeOverdue = false;
			let templateUpdatedAtMillis = null;
			let templateTxFeesSats = null;

			function readRecentJSONCache(key, maxAgeMs) {
				try {
					const raw = sessionStorage.getItem(key);
					if (!raw) return null;
					const parsed = JSON.parse(raw);
					if (!parsed || typeof parsed !== 'object') return null;
					const at = Number(parsed.at || 0);
					if (!Number.isFinite(at) || at <= 0) return null;
					if ((Date.now() - at) > maxAgeMs) return null;
					return parsed.payload ?? null;
				} catch (_) {
					return null;
				}
			}

			function writeJSONCache(key, payload) {
				try {
					sessionStorage.setItem(key, JSON.stringify({
						at: Date.now(),
						payload: payload,
					}));
				} catch (_) {}
			}

		// Used by the saved workers table (hashrate cells render from data-hashrate attributes).
		// This script block runs separately from the main saved-workers dashboard script above,
		// so it must define its own helper to avoid ReferenceError and breaking status boxes.
			function renderStoredHashrates() {
				const cells = document.querySelectorAll('[data-hashrate]');
				cells.forEach((el) => {
					const value = Number(el.getAttribute('data-hashrate'));
					const accuracy = el.getAttribute('data-hashrate-accuracy');
					el.classList.remove('hashrate-warming', 'hashrate-settling', 'hashrate-solid');
					if (!value) {
						el.textContent = 'â€”';
						return;
					}
					const cls = hashrateClassForAccuracy(accuracy);
					if (cls) el.classList.add(cls);
					el.textContent = formatWorkerHashrate(value, accuracy);
				});
			}

		function normalizeFiatCurrency(cur) {
			const s = String(cur ?? '').trim();
			return s ? s.toUpperCase() : 'USD';
		}

		function formatFiatNoDecimals(value, currency) {
			const amount = Number(value);
			if (!Number.isFinite(amount)) {
				return null;
			}
			try {
				return new Intl.NumberFormat('en-US', { style: 'currency', currency, maximumFractionDigits: 0 }).format(amount);
			} catch (_) {
				return amount.toFixed(0);
			}
		}

			function formatHashrate(value) {
			if (!value || value <= 0) {
				return '---';
			}
			const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
			let val = value;
			let idx = 0;
			while (val >= 1000 && idx < units.length - 1) {
				val /= 1000;
				idx++;
			}
				return `${val.toFixed(2)} ${units[idx]}`;
			}

			function formatWorkerHashrate(value, accuracy) {
				const base = formatHashrate(value);
				if (base === 'â€”' || base === '---') return 'â€”';
				let marker = String(accuracy || '').trim();
				if (marker === 'â‰ˆ+' || marker === 'âœ“') marker = '';
				return marker ? `${marker} ${base}` : base;
			}

				function hashrateClassForAccuracy(accuracy) {
					const marker = String(accuracy || '').trim();
					if (marker === '~') return 'hashrate-warming';
					if (marker === 'â‰ˆ') return 'hashrate-settling';
					if (marker === 'â‰ˆ+' || marker === 'âœ“' || marker === '') return 'hashrate-solid';
					return '';
				}

		function formatShareRate(rate) {
			if (!rate) return '0';
			if (rate < 1000) return rate.toFixed(1);
			if (rate < 1000000) return (rate / 1000).toFixed(1) + 'K';
			if (rate < 1000000000) return (rate / 1000000).toFixed(1) + 'M';
			return (rate / 1000000000).toFixed(1) + 'G';
		}

		function normalizePoolTag(tag) {
			if (!tag) return '';
			if (tag[0] === '/') return tag;
			return '/' + tag;
		}

		function updateGridCards(newData) {
			if (!newData) return;
			const poolGroupTitle = document.querySelector('.status-group .status-group-title');
			if (poolGroupTitle && poolGroupTitle.textContent.trim().toLowerCase() === 'pool') {
				poolGroupTitle.textContent = 'Your stats';
			}
			const cardContainers = document.querySelectorAll('.grid > .card');
			cardContainers.forEach(card => {
				const label = card.querySelector('.label');
				const valueEl = card.querySelector('.value');
				if (!label || !valueEl) return;
				const rawLabelText = label.textContent.trim();
				if (rawLabelText === 'Estimated pool hashrate' || rawLabelText === 'Pool hashrate') {
					label.textContent = 'Your hashrate';
				}
				const labelText = label.textContent.trim();
				switch (labelText) {
					case 'Open connections':
						{
							const total = newData.active_miners ?? 0;
							const tls = newData.active_tls_miners ?? 0;
							valueEl.innerHTML = `${total} <span class="text-sm" style="color:#666;">(${tls} TLS)</span>`;
						}
						break;
					case 'Shares per minute':
						{
							const rate = newData.shares_per_minute ?? 0;
							const workers = newData.active_miners ?? 0;
							const avgPerWorker = workers > 0 ? rate / workers : 0;
							if (workers > 0) {
								valueEl.innerHTML = `${formatShareRate(rate)} <span class="text-sm" style="color:#666;">(${formatShareRate(avgPerWorker)}/worker)</span>`;
							} else {
								valueEl.textContent = formatShareRate(rate);
							}
							const contextEl = card.querySelector('.card-context');
							if (contextEl) {
								if (workers > 0) {
									contextEl.textContent = `${formatShareRate(avgPerWorker)} avg/worker`;
								} else {
									contextEl.textContent = 'Indicative of server load';
								}
							}
						}
						break;
					case 'Estimated pool hashrate':
					case 'Pool hashrate':
					case 'Your hashrate':
						{
							const rate = typeof window.savedWorkersTotalHashrate === 'number'
								? window.savedWorkersTotalHashrate
								: newData.pool_hashrate;
							valueEl.textContent = formatHashrate(rate);
						}
						break;
				}
			});
		}

		function updateBTCPrice(newData) {
			if (!newData) return;
			const priceEl = document.getElementById('status-btc-price');
			const updatedEl = document.getElementById('status-btc-price-updated');
			fiatCurrency = normalizeFiatCurrency(newData.fiat_currency || FIAT_CURRENCY);
			const price = Number(newData.btc_price_fiat ?? 0);
			btcPriceFiat = price;
			if (priceEl) {
				const formatted = price > 0 ? formatFiatNoDecimals(Math.round(price), fiatCurrency) : null;
				priceEl.textContent = formatted ? ('BTC ' + formatted + ' ' + fiatCurrency) : '--';
			}
			if (updatedEl) {
				const ts = newData.btc_price_updated_at;
				if (ts) {
					try {
						const d = new Date(ts);
						updatedEl.textContent = 'Updated ' + d.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
					} catch (_) {
						updatedEl.textContent = 'Updated --';
					}
				} else {
					updatedEl.textContent = 'Updated --';
				}
			}
		}

		function updateOverviewDOM(newData) {
			if (!newData) return;
			if (poolTagEl) {
				const tag = normalizePoolTag(newData.pool_tag);
				poolTagEl.textContent = tag || '--';
			}
			updateGridCards(newData);
			updateBTCPrice(newData);
		}

		function formatOddsText(chance) {
			if (!chance || chance <= 0) {
				return '1 in âˆž';
			}
			const ratio = 1 / chance;
			if (!Number.isFinite(ratio)) {
				return '1 in âˆž';
			}

			const largeUnits = [
				{ value: 1e12, label: 'trillion' },
				{ value: 1e9, label: 'billion' },
				{ value: 1e6, label: 'million' },
			];

			for (const { value, label } of largeUnits) {
				if (ratio >= value) {
					const scaled = ratio / value;
					const precision = scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2;
					const formatted = scaled.toFixed(precision).replace(/\.?0+$/, '');
					return `1 in ${formatted} ${label}`;
				}
			}

			const rounded = Math.max(1, Math.round(ratio));
			return `1 in ${rounded.toLocaleString()}`;
		}

		function formatDifficulty(diff) {
			if (!diff || diff <= 0) {
				return '--';
			}
			if (diff < 1000000) return diff.toFixed(0);
			if (diff >= 1000000000000000) {
				return (diff / 1000000000000000).toFixed(1) + 'P';
			}
			if (diff >= 1000000000000) {
				return (diff / 1000000000000).toFixed(1) + 'T';
			}
			if (diff >= 1000000000) {
				return (diff / 1000000000).toFixed(1) + 'G';
			}
			return (diff / 1000000).toFixed(1) + 'M';
		}

		function formatDuration(seconds) {
			const total = Math.max(0, Math.floor(seconds ?? 0));
			const hours = Math.floor(total / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;
			if (hours > 0) {
				return `${hours}h ${minutes}m`;
			}
			if (minutes > 0) {
				return `${minutes}m ${secs}s`;
			}
			return `${secs}s`;
		}

		function formatBTCShort(sats) {
			const btc = (Number(sats) || 0) / 1e8;
			return `${btc.toFixed(8)} BTC`;
		}

		function formatFiat(amount, currency) {
			const value = Number(amount);
			if (!Number.isFinite(value)) {
				return null;
			}
			try {
				return new Intl.NumberFormat('en-US', { style: 'currency', currency, maximumFractionDigits: 2 }).format(value);
			} catch (_) {
				return '$' + value.toFixed(2);
			}
		}

		function formatHHMMSSUTC(millis) {
			if (typeof millis !== 'number' || !Number.isFinite(millis)) {
				return null;
			}
			const date = new Date(millis);
			if (Number.isNaN(date.getTime())) {
				return null;
			}
			return date.toISOString().substring(11, 19) + ' UTC';
		}

		function formatTimeAgoMillis(millis) {
			if (typeof millis !== 'number' || !Number.isFinite(millis)) {
				return null;
			}
			const diffSec = Math.floor((Date.now() - millis) / 1000);
			if (diffSec < 0) return 'just now';
			if (diffSec < 5) return 'just now';
			if (diffSec < 60) return `${diffSec}s ago`;
			if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m ago`;
			if (diffSec < 86400) return `${Math.floor(diffSec / 3600)}h ago`;
			const days = Math.floor(diffSec / 86400);
			if (days < 7) return `${days}d ago`;
			if (days < 30) return `${Math.floor(days / 7)}w ago`;
			if (days < 365) return `${Math.floor(days / 30)}mo ago`;
			return `${Math.floor(days / 365)}y ago`;
		}

		function renderTemplateTxFees() {
			if (!templateTxFeesEl) {
				return;
			}
			if (typeof templateTxFeesSats !== 'number' || templateTxFeesSats < 0) {
				templateTxFeesEl.textContent = '--';
				if (templateTxFeesUpdatedEl) {
					templateTxFeesUpdatedEl.textContent = 'Updated --';
				}
				return;
			}
			const btcText = formatBTCShort(templateTxFeesSats);
			const currency = normalizeFiatCurrency(fiatCurrency || FIAT_CURRENCY);
			const fiatText = btcPriceFiat > 0 ? formatFiat((Number(templateTxFeesSats) / 1e8) * btcPriceFiat, currency) : null;
			templateTxFeesEl.innerHTML = fiatText
				? `${btcText}<br><span style="opacity:0.7; font-size:0.85em;">(${fiatText} ${currency})</span>`
				: btcText;
			if (templateTxFeesUpdatedEl) {
				const when = formatHHMMSSUTC(templateUpdatedAtMillis);
				const ago = formatTimeAgoMillis(templateUpdatedAtMillis);
				const parts = [];
				if (when) parts.push(when);
				if (ago) parts.push(`(${ago})`);
				templateTxFeesUpdatedEl.textContent = parts.length ? `Updated ${parts.join(' ')}` : 'Updated --';
			}
		}

		function formatDurationDetailed(seconds) {
			const total = Math.max(0, Math.floor(seconds ?? 0));
			const days = Math.floor(total / 86400);
			const hours = Math.floor((total % 86400) / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;

			const parts = [];
			if (days > 0) parts.push(`${days}d`);
			if (hours > 0) parts.push(`${hours}h`);
			if (minutes > 0) parts.push(`${minutes}m`);
			if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

			return parts.slice(0, 3).join(' ');
		}

		function getUpdatedAtMillis(value) {
			if (!value) {
				return null;
			}
			const parsed = Date.parse(value);
			if (Number.isNaN(parsed)) {
				return null;
			}
			return parsed;
		}

		function renderBlockTimeLeft() {
			if (!blockTimeLeftEl) {
				return;
			}
			if (isBlockTimeOverdue) {
				blockTimeLeftEl.textContent = `overdue ${formatDuration(blockTimeOverdueSec)}`;
				return;
			}
			if (typeof blockTimeLeftSec !== 'number') {
				blockTimeLeftEl.textContent = '--';
				return;
			}
			blockTimeLeftEl.textContent = formatDuration(blockTimeLeftSec);
		}

		function renderBlockHistory(recentBlockTimes) {
			if (!blockHistoryEl) {
				return;
			}
			if (!recentBlockTimes || recentBlockTimes.length === 0) {
				blockHistoryEl.innerHTML = '--';
				return;
			}

			const durations = [];
			for (let i = recentBlockTimes.length - 1; i >= 1; i--) {
				const prev = new Date(recentBlockTimes[i - 1]).getTime();
				const curr = new Date(recentBlockTimes[i]).getTime();
				const durationSec = Math.floor((curr - prev) / 1000);
				if (durationSec <= 0) {
					durations.push('timestamp skew');
				} else {
					durations.push(formatDurationDetailed(durationSec));
				}
				if (durations.length >= 3) break;
			}

			if (durations.length === 0) {
				blockHistoryEl.innerHTML = '--';
			} else {
				// Render left-to-right to save vertical space.
				blockHistoryEl.textContent = durations.join(' | ');
			}
		}

		function updateHashrateDisplay(rate) {
			if (!valueEl) return;
			if (typeof window.savedWorkersTotalHashrate === 'number') {
				valueEl.textContent = formatHashrate(window.savedWorkersTotalHashrate);
				return;
			}
			const formatted = formatHashrate(rate);
			if (valueEl.textContent !== formatted) {
				valueEl.textContent = formatted;
			}
		}

		function fetchOverview() {
			fetch('/api/overview', { credentials: 'same-origin' })
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					return response.json();
				})
				.then(data => {
					writeJSONCache(OVERVIEW_CACHE_KEY, data);
					updateOverviewDOM(data);
				})
				.catch(err => {
					console.error('Error fetching overview stats:', err);
				});
		}

		function fetchHashrate() {
			fetch('/api/pool-hashrate', { credentials: 'same-origin' })
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					const updatedAt = response.headers.get('X-JSON-Updated-At');
					return response.json().then(data => ({ data, updatedAt }));
				})
				.then(({ data, updatedAt }) => {
					writeJSONCache(HASHRATE_CACHE_KEY, { data, updatedAt });
					if (data && typeof data.pool_hashrate === 'number') {
						updateHashrateDisplay(data.pool_hashrate);
					}
					if (data && typeof data.template_tx_fees_sats === 'number') {
						templateTxFeesSats = data.template_tx_fees_sats;
					} else {
						templateTxFeesSats = null;
					}
					templateUpdatedAtMillis = getUpdatedAtMillis(data?.template_updated_at) ?? getUpdatedAtMillis(updatedAt || data?.updated_at);
					renderTemplateTxFees();
					if (blockHeightEl && typeof data.block_height === 'number' && data.block_height > 0) {
						const height = data.block_height;
						blockHeightEl.textContent = height.toLocaleString();
						if (blockHeightContextEl) {
							const retarget = data.next_difficulty_retarget;
							if (retarget && typeof retarget.height === 'number' && retarget.height > 0) {
								const parts = [];
								if (typeof retarget.blocks_away === 'number') {
									parts.push(null);
								}
								if (retarget.duration_estimate) {
									parts.push(`~${retarget.duration_estimate}`);
								}
								if (parts.length === 0) {
									parts.push('~--');
								}
								const summary = parts.filter(Boolean).join(' Â· ');
								blockHeightContextEl.innerHTML = `${retarget.height.toLocaleString()}<br><span class="text-sm" style="color:var(--text-muted);">(${summary})</span>`;
							} else {
								const interval = 2016;
								const next = (Math.floor(height / interval) + 1) * interval;
								const remaining = Math.max(0, next - height);
								const durationSeconds = remaining * 10 * 60;
								const durationText = formatDuration(durationSeconds);
								blockHeightContextEl.innerHTML = `${next.toLocaleString()}<br><span class="text-sm" style="color:var(--text-muted);">(~${durationText})</span>`;
							}
						}
					} else if (blockHeightEl) {
						blockHeightEl.textContent = '--';
						if (blockHeightContextEl) {
							blockHeightContextEl.textContent = '--';
						}
					}
					let networkHashrate = null;
					if (blockDifficultyEl && typeof data.block_difficulty === 'number') {
						blockDifficultyEl.textContent = formatDifficulty(data.block_difficulty);
						networkHashrate = data.block_difficulty * 4294967296 / (10 * 60);
					}
					if (networkHashrateEl) {
						const networkHashrateText = networkHashrate ? formatHashrate(networkHashrate) : '--';
						networkHashrateEl.textContent = networkHashrateText;
					}
					if (blockChanceEl) {
						let chanceText = '--';
						if (networkHashrate && typeof data.pool_hashrate === 'number' && data.pool_hashrate > 0) {
							const share = Math.min(1, data.pool_hashrate / networkHashrate);
							const chance = 1 - Math.pow(1 - share, 52560);
							chanceText = formatOddsText(chance);
						}
						blockChanceEl.textContent = chanceText;
					}
					if (blockTimeLeftEl) {
						let secondsLeft = null;

						if (typeof data.block_time_left_sec === 'number' && data.block_time_left_sec >= 0) {
							secondsLeft = data.block_time_left_sec;
							const updatedMillis = getUpdatedAtMillis(updatedAt || data.updated_at);
							if (updatedMillis !== null) {
								const ageSec = Math.max(0, (Date.now() - updatedMillis) / 1000);
								secondsLeft = secondsLeft - ageSec;
							}
						} else if (data.recent_block_times && data.recent_block_times.length > 0) {
							const mostRecentBlockTime = new Date(data.recent_block_times[data.recent_block_times.length - 1]).getTime();
							const targetInterval = 10 * 60 * 1000;
							const expectedEndTime = mostRecentBlockTime + targetInterval;
							secondsLeft = Math.floor((expectedEndTime - Date.now()) / 1000);
						}

						if (secondsLeft === null) {
							blockTimeLeftSec = null;
							isBlockTimeOverdue = false;
							blockTimeOverdueSec = 0;
						} else if (secondsLeft <= 0) {
							blockTimeLeftSec = 0;
							isBlockTimeOverdue = true;
							blockTimeOverdueSec = Math.floor(Math.max(0, -secondsLeft));
						} else {
							blockTimeLeftSec = secondsLeft;
							isBlockTimeOverdue = false;
							blockTimeOverdueSec = 0;
						}
						renderBlockTimeLeft();
					}
					if (data.recent_block_times) {
						renderBlockHistory(data.recent_block_times);
					}
				})
				.catch(err => {
					console.error('Error fetching pool hashrate:', err);
				});
		}

			fiatCurrency = normalizeFiatCurrency(FIAT_CURRENCY);
			const cachedOverview = readRecentJSONCache(OVERVIEW_CACHE_KEY, REFRESH_INTERVAL);
			if (cachedOverview) {
				updateOverviewDOM(cachedOverview);
			}
			const cachedHashrate = readRecentJSONCache(HASHRATE_CACHE_KEY, REFRESH_INTERVAL);
			if (cachedHashrate && cachedHashrate.data) {
				const data = cachedHashrate.data;
				const updatedAt = cachedHashrate.updatedAt;
				if (typeof data.pool_hashrate === 'number') {
					updateHashrateDisplay(data.pool_hashrate);
				}
				if (typeof data.template_tx_fees_sats === 'number') {
					templateTxFeesSats = data.template_tx_fees_sats;
				} else {
					templateTxFeesSats = null;
				}
				templateUpdatedAtMillis = getUpdatedAtMillis(data?.template_updated_at) ?? getUpdatedAtMillis(updatedAt || data?.updated_at);
				renderTemplateTxFees();
				if (blockHeightEl && typeof data.block_height === 'number' && data.block_height > 0) {
					blockHeightEl.textContent = data.block_height.toLocaleString();
				}
				if (blockDifficultyEl && typeof data.block_difficulty === 'number') {
					blockDifficultyEl.textContent = formatDifficulty(data.block_difficulty);
				}
				if (data.recent_block_times) {
					renderBlockHistory(data.recent_block_times);
				}
			}
			fetchOverview();
			renderStoredHashrates();
			fetchHashrate();
		setInterval(fetchOverview, REFRESH_INTERVAL);
		setInterval(fetchHashrate, REFRESH_INTERVAL);
		setInterval(() => {
			renderTemplateTxFees();
			if (typeof blockTimeLeftSec !== 'number') {
				return;
			}
			if (isBlockTimeOverdue) {
				blockTimeOverdueSec += 1;
			} else {
				blockTimeLeftSec -= 1;
				if (blockTimeLeftSec <= 0) {
					blockTimeLeftSec = 0;
					isBlockTimeOverdue = true;
					blockTimeOverdueSec = 0;
				}
			}
			renderBlockTimeLeft();
		}, 1000);
	})();
	</script>
	{{end}}
</body>
</html>
