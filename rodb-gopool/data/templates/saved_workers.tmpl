{{/* Saved workers page template */}}
<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="icon" type="image/png" sizes="64x64" href="/favicon.png">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{{if .BrandDomain}}{{.BrandDomain}}{{else}}{{.BrandName}}{{end}} â€” Saved Workers</title>
	<link rel="stylesheet" href="/style.css">
	<style>
		.discord-dialog {
			max-width: 560px;
			width: calc(100vw - 32px);
			border: 1px solid #2a2f3a;
			border-radius: 12px;
			padding: 0;
			background: #0f1218;
			color: var(--text, #e8ecf7);
			box-shadow: 0 18px 60px rgba(0,0,0,0.6);
		}
		.discord-dialog::backdrop { background: rgba(0,0,0,0.55); }
		.discord-dialog-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			padding: 14px 14px 10px 14px;
			border-bottom: 1px solid #242a36;
		}
		.discord-dialog-body { padding: 14px; }
		.discord-dialog-code {
			display: flex;
			align-items: center;
			gap: 10px;
			flex-wrap: wrap;
			margin-top: 10px;
		}
		.discord-dialog-code .mono {
			padding: 8px 10px;
			border-radius: 10px;
			background: #0b0d12;
			border: 1px solid #2a2f3a;
			cursor: pointer;
			user-select: all;
		}
		.discord-dialog-actions { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 12px; }

		.offline-list li {
			display: grid;
			grid-template-columns: 1fr auto auto auto;
			align-items: center;
			gap: 10px;
		}
		.offline-worker-meta { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
		.offline-worker-meta a { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
		.offline-last-online { color: var(--text-muted); }
		@media (max-width: 540px) {
			.offline-list li {
				grid-template-columns: 1fr auto;
				grid-template-rows: auto auto;
				align-items: start;
			}
			.offline-list li .offline-actions {
				grid-column: 1 / -1;
				display: flex;
				justify-content: flex-end;
				gap: 8px;
			}
		}
		.hashrate-settling {
			opacity: 0.82;
		}
		.hashrate-warming {
			opacity: 0.72;
		}
		.hashrate-solid {
			opacity: 1;
		}
		.worker-graphs-dialog {
			max-width: 980px;
			width: calc(100vw - 24px);
			border: 1px solid #2a2f3a;
			border-radius: 12px;
			padding: 0;
			background: #0f1218;
			color: var(--text, #e8ecf7);
			box-shadow: 0 18px 60px rgba(0,0,0,0.6);
		}
		.worker-graphs-dialog::backdrop { background: rgba(0,0,0,0.55); }
		.worker-graphs-header {
			display:flex;
			align-items:center;
			justify-content:space-between;
			gap:12px;
			padding:14px;
			border-bottom:1px solid #242a36;
		}
		.worker-graphs-body { padding: 14px; display:grid; gap:12px; }
		.worker-graphs-panel {
			border: 1px solid #242a36;
			border-radius: 10px;
			padding: 10px;
			background: #0b0d12;
		}
		.worker-graphs-panel .label {
			margin-bottom: 8px;
			color: var(--text-muted);
			font-size: 0.9rem;
		}
		.worker-graphs-canvas {
			width: 100%;
			height: 180px;
			display: block;
		}
		.worker-graph-btn {
			display:inline-flex;
			align-items:center;
			justify-content:center;
			min-width:36px;
			padding: 6px 8px;
		}
		.worker-inline-spark {
			width: 88px;
			height: 14px;
			display: block;
			border-radius: 4px;
			background: rgba(255,255,255,0.02);
			margin-top: 3px;
		}
		.worker-inline-spark-combined {
			width: 100%;
			height: 30px;
			margin-top: 0;
			max-width: 100%;
		}
		.saved-workers-online-spark-slot {
			display: inline-flex;
			align-items: center;
			flex: 1 1 132px;
			min-width: 96px;
			max-width: 220px;
			min-height: 30px;
		}
		.saved-workers-online-table thead th {
			position: static;
		}
		.saved-workers-online-cell {
			padding: 0 !important;
		}
		.saved-workers-online-row-main td {
			border-bottom: 0;
		}
		.saved-workers-online-row-detail td {
			padding-top: 0 !important;
			border-bottom: 0;
		}
		.saved-workers-online-row:hover td {
			background: transparent !important;
		}
		.saved-workers-online-block {
			display: grid;
			gap: 8px;
			padding: 10px 8px;
		}
		.saved-workers-online-row-main:not(:first-child) .saved-workers-online-block.top {
			margin-top: 12px;
			padding-top: 14px;
			border-top: 2px solid rgba(124, 151, 214, 0.22);
		}
		.saved-workers-online-block.top {
			padding-bottom: 6px;
		}
		.saved-workers-online-block.bottom {
			padding-top: 8px;
			padding-bottom: 6px;
			border-top: 0;
		}
		.saved-workers-online-row-detail:not(:last-child) .saved-workers-online-block.bottom {
			padding-bottom: 14px;
			border-bottom: 0;
			box-shadow: none;
		}
		.saved-workers-online-line {
			display: flex;
			align-items: center;
			gap: 12px;
			flex-wrap: wrap;
		}
		.saved-workers-online-block.top .saved-workers-online-line {
			align-items: flex-start;
			justify-content: flex-start;
		}
		.saved-workers-online-block.bottom .saved-workers-online-line {
			justify-content: flex-start;
			gap: 16px;
		}
		.saved-workers-online-name {
			min-width: 180px;
			flex: 0 1 240px;
		}
		.saved-workers-online-name a {
			display: inline-block;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		.saved-workers-online-stats {
			display: flex;
			flex-wrap: wrap;
			gap: 8px 12px;
			align-items: center;
			justify-content: flex-start;
			min-width: 0;
			flex: 1 1 320px;
		}
		.saved-workers-online-pill {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			padding: 4px 8px;
			border: 1px solid rgba(255,255,255,0.08);
			border-radius: 999px;
			background: rgba(255,255,255,0.02);
			min-height: 30px;
		}
		.saved-workers-online-pill-label {
			color: var(--text-muted);
			font-size: 13px;
			white-space: nowrap;
		}
		.saved-workers-online-pill-value {
			font-size: 14px;
			white-space: nowrap;
		}
		.saved-workers-online-pill .worker-inline-spark {
			margin-top: 0;
			margin-left: 4px;
		}
		.saved-workers-online-actions {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			align-items: center;
			justify-content: flex-end;
		}
		.saved-workers-online-actions form {
			margin: 0;
		}
		.saved-workers-online-mobile-legend {
			display: none;
		}
		.saved-workers-online-mobile-table-legend {
			display: none;
		}
		.saved-workers-online-action-remove-mobile {
			display: none;
		}
		.saved-workers-online-mobile-inline-extra {
			display: none;
		}
		[data-theme="light"] .saved-workers-top-badge {
			background: rgba(191, 116, 7, 0.14);
			color: #8a5200;
			border-color: rgba(138, 82, 0, 0.45);
		}
		.saved-workers-online-block.bottom .saved-workers-online-actions {
			justify-content: flex-start;
			flex: 0 1 240px;
			min-width: 180px;
		}
		@media (max-width: 900px) {
			.saved-workers-online-line {
				align-items: flex-start;
			}
			.saved-workers-online-actions {
				width: 100%;
				justify-content: flex-start;
			}
			.saved-workers-online-stats {
				justify-content: flex-start;
			}
		}
		@media (max-width: 540px) {
			.saved-workers-online-row-detail {
				display: none;
			}
			.saved-workers-online-name {
				min-width: 0;
				flex: 1 1 auto;
			}
			.saved-workers-online-block.top .saved-workers-online-line,
			.saved-workers-online-block.bottom .saved-workers-online-line {
				gap: 6px 8px;
				flex-wrap: wrap;
				overflow-x: visible;
			}
			.saved-workers-online-block.top .saved-workers-online-name a {
				max-width: 100%;
			}
			.saved-workers-online-block.top .saved-workers-online-stats {
				flex: 1 1 100%;
				display: grid;
				grid-template-columns: repeat(5, minmax(0, 1fr));
				gap: 6px;
				align-items: center;
				order: 3;
			}
			.saved-workers-online-block.bottom .saved-workers-online-stats {
				flex: 1 1 100%;
				display: flex;
				flex-wrap: nowrap;
				gap: 6px;
				align-items: center;
				overflow-x: auto;
				-webkit-overflow-scrolling: touch;
				scrollbar-width: thin;
			}
			.saved-workers-online-mobile-table-legend {
				display: grid;
				grid-template-columns: repeat(5, minmax(0, 1fr));
				gap: 6px;
				margin-top: 10px;
				padding: 6px 8px;
				border: 1px solid rgba(255,255,255,0.06);
				border-radius: 8px;
				background: rgba(255,255,255,0.02);
			}
			.saved-workers-online-mobile-table-legend .saved-workers-online-mobile-legend {
				display: grid;
				grid-template-columns: repeat(5, minmax(0, 1fr));
				grid-column: 1 / -1;
				gap: 6px;
			}
			.saved-workers-online-mobile-table-legend .saved-workers-online-mobile-legend > span + span {
				border-left: 1px solid rgba(255,255,255,0.14);
				padding-left: 6px;
			}
			.saved-workers-online-mobile-legend > span {
				font-size: 10px;
				color: var(--text-muted);
				text-transform: uppercase;
				letter-spacing: 0.05em;
				white-space: nowrap;
				text-align: center;
			}
			.saved-workers-online-block.top .saved-workers-online-spark-slot {
				flex: 0 0 80px;
				min-width: 80px;
				max-width: 80px;
				min-height: 24px;
			}
			.saved-workers-online-block.top .worker-inline-spark-combined {
				height: 24px;
			}
			.saved-workers-online-block.bottom .saved-workers-online-actions {
				flex: 1 1 100%;
				flex-wrap: nowrap;
				width: auto;
				justify-content: flex-start;
				overflow-x: auto;
				-webkit-overflow-scrolling: touch;
				scrollbar-width: thin;
			}
			.saved-workers-online-pill {
				flex: 0 0 auto;
			}
			.saved-workers-online-block.top .saved-workers-online-pill {
				display: inline-flex;
				width: 100%;
				justify-content: center;
			}
			.saved-workers-online-block.top .saved-workers-online-pill + .saved-workers-online-pill {
				border-left: 1px solid rgba(255,255,255,0.14);
				padding-left: 6px;
			}
			.saved-workers-online-pill {
				padding: 0;
				border: 0;
				border-radius: 0;
				background: transparent;
				min-height: 0;
			}
			.saved-workers-online-pill-label {
				display: none;
			}
			.saved-workers-online-pill-value {
				font-size: 12px;
			}
			.saved-workers-online-pill-mobile-hide,
			.saved-workers-online-spark-slot,
			.saved-workers-online-action-reboot,
			.saved-workers-online-action-graph-mobile-hide,
			.saved-workers-online-action-remove-bottom-mobile-hide {
				display: none !important;
			}
			.saved-workers-online-action-remove-mobile {
				display: inline-flex;
				align-items: center;
				order: 2;
				margin-left: auto;
			}
			.saved-workers-online-name {
				order: 1;
			}
			.saved-workers-online-mobile-inline-extra {
				display: inline-flex;
			}
		}
	</style>
</head>
<body>
	{{template "header" .}}
	<main class="page" id="content">
		<noscript>
			<div class="card">
				<p class="text-sm" style="color:#f88d8d;margin:0;">
					JavaScript is required to use the saved workers dashboard.
				</p>
			</div>
		</noscript>
		{{if .ClerkUser}}
		<div class="panel-stack panel-stack-wide">
			<div class="saved-workers-status">
				{{template "status_boxes" .}}
			</div>

			<div class="card graph-card">
				<div class="graph-card-header">
					<div class="label">Saved Worker History</div>
					<p class="text-sm graph-card-description" id="savedWorkersTopChartMeta">
						Blue bars: total hashrate. Gold line: best share.
					</p>
				</div>
				<canvas id="savedWorkersHashrateChart" style="width:100%;height:220px;"></canvas>
			</div>

			<div class="card" id="onlineWorkersCard" {{if not .OnlineWorkerEntries}}style="display:none;"{{end}}>
				<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
					<h2 style="margin-top:0;">Your workers</h2>
					<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
						<span class="badge saved-workers-top-badge">Slots: <span id="savedCount">{{.SavedWorkersCount}}</span> / <span id="savedMax">{{.SavedWorkersMax}}</span></span>
						<span class="badge saved-workers-top-badge">Online: <span id="onlineCount">{{.SavedWorkersOnline}}</span></span>
					</div>
				</div>
				<p class="text-sm" style="color:var(--text-muted); margin:8px 0 0;">
					For workers sharing the same wallet and name, only the first 16 are displayed here. <span aria-hidden="true">â€¢</span> Force reset button: bans for 30s, then disconnects active sessions so the miner reconnects cleanly. <span aria-hidden="true">â€¢</span> Hashrate markers: <span class="mono">~</span> warming, <span class="mono">â‰ˆ</span> settling, stable (no symbol).
				</p>
				<div class="saved-workers-sort" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin-top:10px;">
					<label class="text-sm mono" for="savedWorkersSortField" style="margin:0;">Sort by</label>
					<select id="savedWorkersSortField" class="input" style="max-width:220px;">
						<option value="connection_seq">Connection #</option>
						<option value="name">Name</option>
						<option value="hashrate">Hashrate</option>
						<option value="best_difficulty">Best Share</option>
						<option value="difficulty">Difficulty</option>
						<option value="shares_per_minute">Shares/min</option>
						<option value="accepted">Accepted</option>
						<option value="rejected">Rejected</option>
						<option value="connection_duration_seconds">Connected</option>
						<option value="uptime_history">Uptime</option>
					</select>
					<button id="savedWorkersSortOrder" class="btn btn-secondary" type="button" aria-label="Toggle sort order">Desc â†“</button>
				</div>
				<div class="saved-workers-online-mobile-table-legend" aria-hidden="true">
					<div class="saved-workers-online-mobile-legend">
						<span>Hash</span>
						<span>Best</span>
						<span>Rej</span>
						<span>Conn</span>
						<span>Up</span>
					</div>
				</div>
				<div style="overflow-x:auto; margin-top:12px;">
					<table class="table saved-workers-online-table">
					<thead>
						<tr>
							<th>Worker</th>
						</tr>
					</thead>
						<tbody id="onlineWorkersBody">
							{{if .OnlineWorkerEntries}}
								{{range .OnlineWorkerEntries}}
					<tr class="saved-workers-online-row saved-workers-online-row-main">
						<td class="saved-workers-online-cell">
							<div class="saved-workers-online-block top">
								<div class="saved-workers-online-line">
									<form method="post" action="/worker/remove" data-remove-worker="{{.Name}}" class="saved-workers-online-action-remove-mobile">
										<input type="hidden" name="hash" value="{{.Hash}}">
										<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
											<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
												<polyline points="3 6 5 6 21 6"></polyline>
												<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
												<path d="M10 11v6"></path>
												<path d="M14 11v6"></path>
												<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
											</svg>
										</button>
									</form>
									<div class="saved-workers-online-name">
										<a class="mono sensitive-worker worker-link" data-worker-name="{{.Name}}" data-worker-hash="{{.Hash}}" href="/worker/sha256?hash={{.Hash}}"></a>
									</div>
									<div class="saved-workers-online-stats">
										<span class="saved-workers-online-spark-slot">
											<canvas class="worker-inline-spark worker-inline-spark-combined" width="128" height="16" data-worker-inline-chart="combined" data-worker-hash="{{.Hash}}" aria-label="Worker hashrate and best share sparkline"></canvas>
										</span>
										<span class="saved-workers-online-pill">
											<span class="saved-workers-online-pill-label">Hashrate</span>
											<span data-hashrate="{{printf "%.0f" .Hashrate}}" data-hashrate-accuracy="{{.HashrateAccuracy}}" class="hashrate-value saved-workers-online-pill-value">
												â€”
											</span>
										</span>
										<span class="saved-workers-online-pill">
											<span class="saved-workers-online-pill-label">Best ever</span>
											<span class="saved-workers-online-pill-value">{{formatDiff .BestDifficulty}}</span>
										</span>
										<span class="saved-workers-online-pill saved-workers-online-mobile-inline-extra"><span class="saved-workers-online-pill-label">Rejected</span><span class="saved-workers-online-pill-value">{{.Rejected}}</span></span>
										<span class="saved-workers-online-pill saved-workers-online-mobile-inline-extra"><span class="saved-workers-online-pill-label">Connected</span><span class="saved-workers-online-pill-value">{{humanDuration .ConnectedDuration}}</span></span>
										<span class="saved-workers-online-pill saved-workers-online-mobile-inline-extra"><span class="saved-workers-online-pill-label">Uptime</span><span class="saved-workers-online-pill-value" data-worker-uptime-history="{{.Hash}}">â€”</span></span>
										<span class="saved-workers-online-pill saved-workers-online-pill-mobile-hide"><span class="saved-workers-online-pill-label">Diff</span><span class="saved-workers-online-pill-value">{{formatDiff .Difficulty}}</span></span>
										<span class="saved-workers-online-pill saved-workers-online-pill-mobile-hide"><span class="saved-workers-online-pill-label">Shares/min</span><span class="saved-workers-online-pill-value">{{formatShareRate .ShareRate}}</span></span>
									</div>
								</div>
							</div>
						</td>
					</tr>
					<tr class="saved-workers-online-row saved-workers-online-row-detail">
						<td class="saved-workers-online-cell">
							<div class="saved-workers-online-block bottom">
								<div class="saved-workers-online-line">
									<div class="saved-workers-online-actions">
										<button class="btn btn-secondary worker-graph-btn worker-history-open saved-workers-online-action-graph-mobile-hide" type="button" data-worker-name="{{.Name}}" data-worker-hash="{{.Hash}}" aria-label="Open worker graphs" title="Open worker graphs">
											<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
												<path d="M3 3v18h18"></path>
												<path d="M7 14l4-4 3 3 5-6"></path>
											</svg>
										</button>
										{{if $.DiscordNotificationsEnabled}}
											<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="{{.Hash}}" data-notify-enabled="{{if .NotifyEnabled}}1{{else}}0{{end}}" aria-label="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}" title="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}">
												{{if .NotifyEnabled}}ðŸ””{{else}}ðŸ”•{{end}}
											</button>
										{{end}}
										<form method="post" action="/worker/reconnect" data-reconnect-worker="{{.Name}}" class="saved-workers-online-action-reboot">
											<input type="hidden" name="hash" value="{{.Hash}}">
											<button class="btn btn-secondary" type="submit" aria-label="Reboot worker" title="Force reset (30s ban + disconnect)">
												Reboot
											</button>
										</form>
										<form method="post" action="/worker/remove" data-remove-worker="{{.Name}}" class="saved-workers-online-action-remove-bottom-mobile-hide">
											<input type="hidden" name="hash" value="{{.Hash}}">
											<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
												<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
													<polyline points="3 6 5 6 21 6"></polyline>
													<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
													<path d="M10 11v6"></path>
													<path d="M14 11v6"></path>
													<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
												</svg>
											</button>
										</form>
									</div>
									<div class="saved-workers-online-stats">
										<span class="saved-workers-online-pill saved-workers-online-pill-mobile-hide"><span class="saved-workers-online-pill-label">Accepted</span><span class="saved-workers-online-pill-value">{{.Accepted}}</span></span>
										<span class="saved-workers-online-pill"><span class="saved-workers-online-pill-label">Rejected</span><span class="saved-workers-online-pill-value">{{.Rejected}}</span></span>
										<span class="saved-workers-online-pill"><span class="saved-workers-online-pill-label">Connected</span><span class="saved-workers-online-pill-value">{{humanDuration .ConnectedDuration}}</span></span>
										<span class="saved-workers-online-pill"><span class="saved-workers-online-pill-label">Uptime</span><span class="saved-workers-online-pill-value" data-worker-uptime-history="{{.Hash}}">â€”</span></span>
									</div>
								</div>
							</div>
						</td>
					</tr>
								{{end}}
							{{else}}
								<tr><td class="text-sm">No saved workers online right now.</td></tr>
							{{end}}
						</tbody>
					</table>
				</div>
			</div>

			{{$offlineCount := len .OfflineWorkerEntries}}
			<div class="card offline-card" id="offlineSection" {{if eq $offlineCount 0}}style="display:none;"{{end}}>
				<div class="offline-card-header">
					<div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
						<h2 style="margin:0;">Offline Workers</h2>
						<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;">
							<span class="badge badge-danger" id="offlineCountBadge" style="margin-left:8px; {{if eq $offlineCount 0}}display:none;{{end}}">
								{{$offlineCount}} offline
							</span>
						</div>
					</div>
				</div>
				<ul class="offline-list text-sm" id="offlineWorkersList" {{if eq $offlineCount 0}}style="display:none;"{{end}}>
					{{range .OfflineWorkerEntries}}
						<li>
								<div class="offline-worker-meta">
									<a class="mono sensitive-worker worker-link" data-worker-name="{{.Name}}" data-worker-hash="{{.Hash}}" href="/worker/sha256?hash={{.Hash}}"></a>
									<span class="text-sm offline-last-online" data-last-online-at="{{.LastOnlineAt}}"></span>
									<span class="text-sm" style="color:var(--text-muted);">Best share: {{formatDiff .BestDifficulty}}</span>
								</div>
							<span class="badge badge-danger">Offline</span>
							<div class="offline-actions" style="display:flex; gap:8px; justify-content:flex-end; align-items:center;">
							{{if $.DiscordNotificationsEnabled}}
									<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="{{.Hash}}" data-notify-enabled="{{if .NotifyEnabled}}1{{else}}0{{end}}" aria-label="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}" title="{{if .NotifyEnabled}}Disable pings for this worker{{else}}Enable pings for this worker{{end}}">
										{{if .NotifyEnabled}}ðŸ””{{else}}ðŸ”•{{end}}
									</button>
								{{end}}
								<form method="post" action="/worker/remove" style="margin:0;" data-remove-worker="{{.Name}}">
									<input type="hidden" name="hash" value="{{.Hash}}">
									<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
										<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
											<polyline points="3 6 5 6 21 6"></polyline>
											<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
											<path d="M10 11v6"></path>
											<path d="M14 11v6"></path>
											<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
										</svg>
									</button>
								</form>
							</div>
						</li>
					{{end}}
				</ul>
				<p id="offlineEmptyMessage" class="text-sm" style="color:var(--text-muted); margin-top:10px; display:none;">
					All saved workers are currently online.
				</p>
			</div>

			<div class="card">
				<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
					<h2 style="margin-top:0;">
						{{if eq .SavedWorkersCount 0}}
							Add your first worker!
						{{else}}
							Add workers
						{{end}}
					</h2>
				</div>
				<form method="post" action="/worker/save" style="margin-top:12px;">
					<div class="input-row">
						<input class="input" type="text" name="worker" placeholder="wallet.worker">
						<button class="btn" type="submit">Add</button>
					</div>
				</form>
			</div>

			<div class="card">
				<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
					<div>
						<h2 style="margin-top:0;">Find miners by wallet</h2>
						<p class="text-sm" style="color:var(--text-muted); margin:4px 0 0;">
							Paste a wallet address to list active workers using it and save them without duplicates.
						</p>
					</div>
				</div>
				<form method="get" action="/saved-workers" id="walletLookupForm" style="margin-top:12px;">
					<div class="label">Wallet address</div>
					<div class="input-row">
						<input class="input" type="text" id="walletLookupInput" name="wallet" placeholder="bc1..." autocomplete="off">
						<input type="hidden" name="hash" id="walletLookupHash" value="{{.WalletLookupHash}}">
						<button class="btn" type="submit">Search wallet</button>
					</div>
				</form>
				{{if .WalletLookupError}}
					<p class="text-sm" style="color:#f88d8d; margin-top:10px;">{{.WalletLookupError}}</p>
				{{else if and .WalletLookupHash (gt (len .WalletLookupResults) 0)}}
					<p class="text-sm" style="margin-top:10px; color:#b3bbd4;">
						Showing active workers for wallet hash <span class="mono sensitive-data">{{shortID .WalletLookupHash}}</span>.
					</p>
				{{end}}
				{{if gt (len .WalletLookupResults) 0}}
					<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-top:10px;">
						<div class="text-sm" style="color:var(--text-muted);">
							{{len .WalletLookupResults}} {{if gt (len .WalletLookupResults) 1}}miners{{else}}miner{{end}} found.
						</div>
						<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
							{{if gt .WalletLookupUnsavedCount 0}}
								<button id="walletLookupAddAll" class="btn btn-highlight" type="button" aria-label="Add all miners from this wallet">
									Add all ({{.WalletLookupUnsavedCount}})
								</button>
							{{else}}
								<button class="btn btn-secondary" type="button" disabled>All results saved</button>
							{{end}}
						</div>
					</div>
					<p class="text-sm" style="color:var(--text-muted); margin-top:6px;">
						Add actions skip workers that are already saved to prevent duplicates.
					</p>
					<div style="overflow-x:auto; margin-top:12px;">
						<table class="table">
							<thead>
								<tr>
									<th>Worker</th>
									<th>Hashrate</th>
									<th></th>
								</tr>
							</thead>
							<tbody>
								{{range .WalletLookupResults}}
									<tr>
										<td>
											<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
												<a class="mono sensitive-worker worker-link" data-worker-name="{{if .DisplayName}}{{.DisplayName}}{{else}}{{.Name}}{{end}}" data-worker-hash="{{.WorkerSHA256}}" href="/worker/sha256?hash={{.WorkerSHA256}}"></a>
											</div>
										</td>
										<td>{{if gt .RollingHashrate 0.0}}{{formatHashrate .RollingHashrate}}{{else}}â€”{{end}}</td>
										<td style="text-align:right;">
											{{if .AlreadySaved}}
												<span class="badge" style="display:inline-flex; gap:4px;">Saved</span>
											{{else}}
												<button type="button" class="btn btn-secondary wallet-lookup-add" data-worker="{{.Name}}" data-worker-hash="{{.WorkerSHA256}}" aria-label="Save {{.Name}} to saved workers">
													Add
												</button>
											{{end}}
										</td>
									</tr>
								{{end}}
							</tbody>
						</table>
					</div>
				{{end}}
			</div>

			<div class="card">
				<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
					<h2 style="margin-top:0;">Options</h2>
				</div>
				<div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px;">
					{{if .DiscordNotificationsEnabled}}
						<button
							id="notifyAllToggle"
							class="btn btn-secondary"
							type="button"
							{{if not .DiscordNotificationsRegistered}}disabled{{end}}
							data-enabled="{{if .DiscordNotificationsUserEnabled}}1{{else}}0{{end}}"
							aria-label="{{if .DiscordNotificationsRegistered}}{{if .DiscordNotificationsUserEnabled}}Disable notifications{{else}}Enable notifications{{end}}{{else}}Register first to manage notifications{{end}}"
							title="{{if .DiscordNotificationsRegistered}}{{if .DiscordNotificationsUserEnabled}}Disable notifications{{else}}Enable notifications{{end}}{{else}}Register first to manage notifications{{end}}"
						>{{if .DiscordNotificationsUserEnabled}}ðŸ”• Disable notifications{{else}}ðŸ”” Enable notifications{{end}}</button>
						<button id="oneTimeCodeGenerate" class="btn btn-highlight{{if .DiscordNotificationsRegistered}} no-glow{{end}}" type="button" aria-label="Connect Your Discord Account!">
							Connect Your Discord Account!
						</button>
					{{end}}
					<a class="btn btn-secondary" href="/logout?redirect=/worker" aria-label="Sign out" style="gap:8px;">
						<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
							<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
							<polyline points="16 17 21 12 16 7"></polyline>
							<line x1="21" y1="12" x2="9" y2="12"></line>
						</svg>
						<span>Sign out</span>
					</a>
				</div>
			</div>
		</div>
		{{else}}
		<div class="card">
			<h2>Saved workers</h2>
			<p class="text-sm">Sign in to save workers for quick access.</p>
			<a class="btn" href="/sign-in?redirect=/saved-workers">Sign in</a>
		</div>
		{{end}}

	{{template "footer" .}}
	</main>
	{{if .DiscordNotificationsEnabled}}
	<dialog id="discordNotifDialog" class="discord-dialog" aria-label="Discord notifications setup">
		<div class="discord-dialog-header">
			<div style="display:flex; flex-direction:column; gap:2px;">
			<div style="font-weight:700;">Connect your Discord account</div>
			<div class="text-sm" style="color:var(--text-muted);">Get pinged when your saved workers go offline/online or find a block.</div>
		</div>
			<button id="discordNotifClose" class="btn btn-secondary" type="button" aria-label="Close">Close</button>
		</div>
		<div class="discord-dialog-body">
			<div class="text-sm" style="color:var(--text-muted);">
				<ol style="margin:0; padding-left:18px;">
					<li>Generate a one-time code</li>
					<li>In Discord, run <span class="mono">/notify</span> and paste the code</li>
				</ol>
			</div>

			<div class="discord-dialog-code">
				<span id="discordNotifCode" class="mono" style="display:none;" title="Click to copy"></span>
				<button id="discordNotifCopy" class="btn btn-secondary" type="button" style="display:none;">Copy</button>
				<button id="discordNotifRegenerate" class="btn btn-highlight" type="button">Generate code</button>
			</div>

			<div class="discord-dialog-actions">
				<button id="discordInviteBtn" class="btn" type="button" data-discord-url="{{.DiscordURL}}">Open Discord invite</button>
				<a class="btn btn-secondary" href="https://support-apps.discord.com/hc/en-us/articles/26501837786775-Slash-Commands-FAQ" target="_blank" rel="noopener noreferrer">How to use slash commands</a>
			</div>

			<div class="text-sm" style="margin-top:12px;">
				<span id="discordNotifStatus" class="badge" style="display:none;"></span>
				<span id="discordNotifExpires" class="badge" style="display:none;"></span>
			</div>

			<div class="text-sm" style="margin-top:10px; color:var(--text-muted);">
				Closing this dialog clears the code on the server. Codes expire after 5 minutes if unused.
			</div>
		</div>
	</dialog>
	{{end}}
	{{if .ClerkUser}}
	<dialog id="workerGraphsDialog" class="worker-graphs-dialog" aria-label="Saved worker history graphs">
		<div class="worker-graphs-header">
			<div style="display:flex; flex-direction:column; gap:2px; min-width:0;">
				<div style="font-weight:700;" id="workerGraphsTitle">Worker history</div>
				<div class="text-sm mono sensitive-worker" id="workerGraphsSubtitle" data-worker-name="" data-worker-hash="" style="color:var(--text-muted);"></div>
			</div>
			<button id="workerGraphsClose" class="btn btn-secondary" type="button" aria-label="Close">Close</button>
		</div>
		<div class="worker-graphs-body">
			<div id="workerGraphsStatus" class="text-sm" style="color:var(--text-muted);">Select a worker to load graphs.</div>
			<div class="worker-graphs-panel">
				<div class="label">Hashrate + Best share</div>
				<canvas id="workerGraphsCombinedCanvas" class="worker-graphs-canvas"></canvas>
			</div>
		</div>
	</dialog>
	{{end}}
	{{if .ClerkUser}}
	<script src="/sha256.js"></script>
	<script>
		(function() {
		const discordNotificationsEnabled = {{if .DiscordNotificationsEnabled}}true{{else}}false{{end}};
		const clerkEnabled = {{if .ClerkEnabled}}true{{else}}false{{end}};
		const clerkPublishableKey = "{{.ClerkPublishableKey}}";
		const clerkJSURL = "{{.ClerkJSURL}}";
		const clerkLoginURL = "{{.ClerkLoginURL}}";

		let clerkLoadPromise = null;
		let clerkRefreshing = null;

		function redirectToLogin() {
			const url = (clerkLoginURL || '/sign-in?redirect=/saved-workers');
			try { window.location.href = url; } catch (_) {}
		}

		function loadClerkJS() {
			if (!clerkEnabled || !clerkPublishableKey || !clerkJSURL) return Promise.resolve(null);
			if (window.Clerk) return Promise.resolve(window.Clerk);
			if (clerkLoadPromise) return clerkLoadPromise;
			clerkLoadPromise = new Promise((resolve) => {
				const script = document.createElement('script');
				script.async = true;
				script.crossOrigin = 'anonymous';
				script.src = clerkJSURL;
				script.setAttribute('data-clerk-publishable-key', clerkPublishableKey);
				script.onload = () => resolve(window.Clerk || null);
				script.onerror = () => resolve(null);
				document.head.appendChild(script);
			}).then(async (clerk) => {
				try {
					if (clerk && typeof clerk.load === 'function') {
						await clerk.load();
					}
				} catch (_) {}
				return window.Clerk || clerk || null;
			});
			return clerkLoadPromise;
		}

		async function refreshClerkSession() {
			if (!clerkEnabled) return false;
			if (clerkRefreshing) return clerkRefreshing;
			clerkRefreshing = (async () => {
				const clerk = await loadClerkJS();
				if (!clerk) return false;
				try {
					if (clerk.session && typeof clerk.session.getToken === 'function') {
						const token = await clerk.session.getToken();
						if (!token) return false;
						const res = await fetch('/api/auth/session-refresh', {
							method: 'POST',
							credentials: 'same-origin',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ token }),
						});
						return res && res.ok;
					}
				} catch (_) {}
				return false;
			})().finally(() => {
				clerkRefreshing = null;
			});
			return clerkRefreshing;
		}

		async function fetchWithAuthRefresh(url, options) {
			const res = await fetch(url, options);
			if (res.status !== 401) return res;
			const ok = await refreshClerkSession();
			if (ok) {
				const retry = await fetch(url, options);
				if (retry.status !== 401) return retry;
			}
			redirectToLogin();
			return res;
		}

		const walletLookupForm = document.getElementById('walletLookupForm');
		const walletLookupInput = document.getElementById('walletLookupInput');
		const walletLookupHashInput = document.getElementById('walletLookupHash');
		const walletLookupAddAllButton = document.getElementById('walletLookupAddAll');

		function isSHA256Hex(str) {
			return /^[a-f0-9]{64}$/i.test((str || '').trim());
		}

		async function sha256Always(str) {
			if (typeof window.sha256Hex !== 'function') return null;
			try { return await window.sha256Hex(str); } catch (_) { return null; }
		}

		if (walletLookupForm) {
			walletLookupForm.addEventListener('submit', async function(event) {
				event.preventDefault();
				const walletAddress = (walletLookupInput?.value || '').trim();
				if (!walletAddress) {
					alert('Please enter a wallet address or wallet hash');
					return;
				}
				try {
					walletLookupInput.setAttribute('name', 'wallet');
					if (walletLookupHashInput) {
						walletLookupHashInput.value = '';
					}

					if (walletLookupHashInput && isSHA256Hex(walletAddress)) {
						walletLookupHashInput.value = walletAddress.toLowerCase();
						walletLookupInput.removeAttribute('name');
						this.submit();
						return;
					}

					const hash = await sha256Always(walletAddress);
					if (walletLookupHashInput && hash) {
						walletLookupHashInput.value = hash;
						walletLookupInput.removeAttribute('name');
					}
					this.submit();
				} catch (error) {
					console.error('Wallet lookup submit error:', error);
					this.submit();
				}
			});
		}

			async function saveWorkerFromLookup(workerName, button) {
				if (!workerName) {
					return false;
				}
				if (button) {
					button.disabled = true;
				}
				try {
					const payload = new URLSearchParams();
					payload.append('worker', workerName);
					const res = await fetchWithAuthRefresh('/worker/save', {
						method: 'POST',
						credentials: 'same-origin',
						body: payload.toString(),
						headers: {
							'Content-Type': 'application/x-www-form-urlencoded',
						},
					});
				if (!res.ok) {
					throw new Error('Failed to add worker');
				}
				if (button) {
					button.textContent = 'Saved';
					button.classList.remove('wallet-lookup-add');
					button.dataset.saved = '1';
					button.setAttribute('aria-label', 'Worker saved');
					button.disabled = true;
				}
				await refreshSavedWorkers();
				return true;
			} catch (error) {
				console.error('Add worker from wallet lookup failed:', error);
				if (button) {
					button.disabled = false;
				}
				return false;
			}
		}

		function updateWalletLookupAddAllState() {
			if (!walletLookupAddAllButton) {
				return;
			}
			const remaining = Array.from(document.querySelectorAll('.wallet-lookup-add')).filter((btn) => !btn.disabled);
			if (remaining.length === 0) {
				walletLookupAddAllButton.disabled = true;
				walletLookupAddAllButton.textContent = 'All results saved';
				return;
			}
			walletLookupAddAllButton.disabled = false;
			walletLookupAddAllButton.textContent = `Add all (${remaining.length})`;
		}

		function attachWalletLookupAddHandlers() {
			const buttons = document.querySelectorAll('.wallet-lookup-add');
			buttons.forEach((btn) => {
				if (btn.__walletLookupAttached) {
					return;
				}
				btn.__walletLookupAttached = true;
				btn.addEventListener('click', async () => {
					const worker = btn.getAttribute('data-worker') || '';
					await saveWorkerFromLookup(worker, btn);
					updateWalletLookupAddAllState();
				});
			});
		}

		if (walletLookupAddAllButton) {
			walletLookupAddAllButton.addEventListener('click', async () => {
				const buttons = Array.from(document.querySelectorAll('.wallet-lookup-add')).filter((btn) => !btn.disabled);
				if (buttons.length === 0) {
					return;
				}
				walletLookupAddAllButton.disabled = true;
				for (const btn of buttons) {
					const worker = btn.getAttribute('data-worker') || '';
					await saveWorkerFromLookup(worker, btn);
				}
				updateWalletLookupAddAllState();
			});
		}

		// One-time code (server-generated, stored in memory for 5 minutes).
		const oneTimeCodeGenerateBtn = document.getElementById('oneTimeCodeGenerate');
		const discordDialog = document.getElementById('discordNotifDialog');
		const discordDialogClose = document.getElementById('discordNotifClose');
		const discordCodeEl = document.getElementById('discordNotifCode');
		const discordCopyBtn = document.getElementById('discordNotifCopy');
		const discordRegenBtn = document.getElementById('discordNotifRegenerate');
		const discordInviteBtn = document.getElementById('discordInviteBtn');
		const discordStatusEl = document.getElementById('discordNotifStatus');
		const discordExpiresEl = document.getElementById('discordNotifExpires');
		let oneTimeCodeTimeout = null;
		let oneTimeCodeCountdownTimer = null;
		let activeOneTimeCode = '';
		let activeExpiresAtMillis = 0;

		function setBadge(el, text, danger) {
			if (!el) return;
			text = String(text || '');
			if (danger) el.classList.add('badge-danger');
			else el.classList.remove('badge-danger');
			if (text) {
				el.textContent = text;
				el.style.display = '';
			} else {
				el.style.display = 'none';
			}
		}

		const onlineWorkersBody = document.getElementById('onlineWorkersBody');
		const onlineWorkersCard = document.getElementById('onlineWorkersCard');
		const sortFieldSelect = document.getElementById('savedWorkersSortField');
		const sortOrderBtn = document.getElementById('savedWorkersSortOrder');
		const workerGraphsDialog = document.getElementById('workerGraphsDialog');
		const workerGraphsClose = document.getElementById('workerGraphsClose');
		const workerGraphsTitle = document.getElementById('workerGraphsTitle');
		const workerGraphsSubtitle = document.getElementById('workerGraphsSubtitle');
		const workerGraphsStatus = document.getElementById('workerGraphsStatus');
		const workerGraphsCombinedCanvas = document.getElementById('workerGraphsCombinedCanvas');
		const savedWorkersTopChartCanvas = document.getElementById('savedWorkersHashrateChart');
		const savedWorkersTopChartMeta = document.getElementById('savedWorkersTopChartMeta');
		let lastOnlineWorkers = [];
		let currentSortField = 'connection_seq';
		let sortDescending = true;
		const inlineWorkerChartRefreshMS = 2 * 60 * 1000;
		const inlineWorkerChartCache = new Map();
		const workerHashrateFallbackMaxAgeMS = 2 * 60 * 1000;
		const workerHashrateFallback = new Map();
		const workerShareRateFallbackMaxAgeMS = 2 * 60 * 1000;
		const workerShareRateFallback = new Map();
		let savedWorkersTopChartLiveHashrate = 0;
		let savedWorkersTopChartLiveAt = 0;

		function workerHashrateKey(worker) {
			const hash = String(worker?.hash || '').trim().toLowerCase();
			if (hash) {
				return `hash:${hash}`;
			}
			const connectionSeq = Number(worker?.connection_seq || 0);
			if (connectionSeq > 0) {
				return `connseq:${connectionSeq}`;
			}
			const name = String(worker?.name || '').trim();
			if (name) {
				return `name:${name}`;
			}
			return '';
		}

		function pruneWorkerHashrateFallback(nowMillis) {
			for (const [key, sample] of workerHashrateFallback.entries()) {
				if (!sample || !Number.isFinite(sample.value) || sample.value <= 0 || !Number.isFinite(sample.at) || nowMillis-sample.at > workerHashrateFallbackMaxAgeMS) {
					workerHashrateFallback.delete(key);
				}
			}
		}

		function pruneWorkerShareRateFallback(nowMillis) {
			for (const [key, sample] of workerShareRateFallback.entries()) {
				if (!sample || !Number.isFinite(sample.value) || sample.value <= 0 || !Number.isFinite(sample.at) || nowMillis-sample.at > workerShareRateFallbackMaxAgeMS) {
					workerShareRateFallback.delete(key);
				}
			}
		}

		function effectiveWorkerHashrate(worker, nowMillis) {
			const key = workerHashrateKey(worker);
			const raw = Number(worker?.hashrate || 0);
			if (Number.isFinite(raw) && raw > 0) {
				if (key) {
					workerHashrateFallback.set(key, { value: raw, at: nowMillis });
				}
				return raw;
			}
			if (key) {
				const sample = workerHashrateFallback.get(key);
				if (sample && Number.isFinite(sample.value) && sample.value > 0 && Number.isFinite(sample.at) && nowMillis-sample.at <= workerHashrateFallbackMaxAgeMS) {
					return sample.value;
				}
			}
			return 0;
		}

		function effectiveWorkerShareRate(worker, nowMillis) {
			const key = workerHashrateKey(worker);
			const raw = Number(worker?.shares_per_minute || 0);
			if (Number.isFinite(raw) && raw > 0) {
				if (key) {
					workerShareRateFallback.set(key, { value: raw, at: nowMillis });
				}
				return raw;
			}
			if (key) {
				const sample = workerShareRateFallback.get(key);
				if (sample && Number.isFinite(sample.value) && sample.value > 0 && Number.isFinite(sample.at) && nowMillis-sample.at <= workerShareRateFallbackMaxAgeMS) {
					return sample.value;
				}
			}
			return 0;
		}

		function notifyToggleText(enabled) {
			return enabled ? 'ðŸ””' : 'ðŸ”•';
		}

		function notifyToggleTitle(enabled) {
			return enabled ? 'Disable pings for this worker' : 'Enable pings for this worker';
		}

		function notifyAllToggleText(enabled) {
			return enabled ? 'ðŸ”• Disable notifications' : 'ðŸ”” Enable notifications';
		}

		function notifyAllToggleTitle(enabled) {
			return enabled ? 'Disable notifications' : 'Enable notifications';
		}

		function formatHashrate(value) {
			if (!value || value <= 0) {
				return 'â€”';
			}
			const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
			let val = value;
			let idx = 0;
			while (val >= 1000 && idx < units.length - 1) {
				val /= 1000;
				idx++;
			}
			return `${val.toFixed(2)} ${units[idx]}`;
		}

		function formatWorkerHashrate(value, accuracy) {
			const base = formatHashrate(value);
			if (base === 'â€”' || base === '---') return 'â€”';
			let marker = String(accuracy || '').trim();
			if (marker === 'â‰ˆ+' || marker === 'âœ“') marker = '';
			return marker ? `${marker} ${base}` : base;
		}

		function hashrateClassForAccuracy(accuracy) {
			const marker = String(accuracy || '').trim();
			if (marker === '~') return 'hashrate-warming';
			if (marker === 'â‰ˆ') return 'hashrate-settling';
			if (marker === 'â‰ˆ+' || marker === 'âœ“' || marker === '') return 'hashrate-solid';
			return '';
		}

		function formatShareRate(rate) {
			const value = Number(rate || 0);
			if (!value) return '0';
			if (value < 1000) return value.toFixed(1);
			if (value < 1000000) return (value / 1000).toFixed(1) + 'K';
			if (value < 1000000000) return (value / 1000000).toFixed(1) + 'M';
			return (value / 1000000000).toFixed(1) + 'B';
		}

			function formatDifficulty(diff) {
				const value = Number(diff || 0);
				if (!value || value <= 0) return 'â€”';
			if (value < 1000000) return value.toFixed(0);
			if (value >= 1000000000000000) return (value / 1000000000000000).toFixed(1) + 'P';
			if (value >= 1000000000000) return (value / 1000000000000).toFixed(1) + 'T';
			if (value >= 1000000000) return (value / 1000000000).toFixed(1) + 'G';
			return (value / 1000000).toFixed(1) + 'M';
			}

			function formatDifficultyGraph(diff) {
				const value = Number(diff || 0);
				if (!Number.isFinite(value) || value <= 0) return '0';
				if (value < 1000) return value.toFixed(0);
				const units = ['K', 'M', 'G', 'T', 'P', 'E'];
				let scaled = value;
				let idx = -1;
				while (scaled >= 1000 && idx < units.length - 1) {
					scaled /= 1000;
					idx++;
				}
				if (idx < 0) return value.toFixed(0);
				const precision = scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2;
				return scaled.toFixed(precision) + units[idx];
			}

			function formatLastShare(value) {
				if (!value) return 'â€”';
				const ts = Date.parse(value);
				if (!isFinite(ts) || ts <= 0) return 'â€”';
				const seconds = Math.floor((Date.now() - ts) / 1000);
				if (seconds < 60) return 'Just now';
				return formatTimeAgo(seconds);
			}

		function formatDuration(seconds) {
			const total = Math.max(0, Math.floor(seconds || 0));
			const hours = Math.floor(total / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;
			if (hours > 0) return `${hours}h ${minutes}m`;
			if (minutes > 0) return `${minutes}m ${secs}s`;
			return `${secs}s`;
		}

		function formatGraphTimeSpan(seconds) {
			const total = Math.max(0, Math.floor(Number(seconds) || 0));
			const days = Math.floor(total / 86400);
			const hours = Math.floor((total % 86400) / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;
			if (days > 0) return hours > 0 ? `${days}d ${hours}h` : `${days}d`;
			if (hours > 0) return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
			if (minutes > 0) return `${minutes}m`;
			return `${secs}s`;
		}

		function formatLatency(ms) {
			const v = Number(ms || 0);
			if (!isFinite(v) || v <= 0) return 'â€”';
			if (v < 1) return `${Math.max(1, Math.round(v * 1000))}us`;
			if (v < 1000) return `${Math.round(v)}ms`;
			const sec = v / 1000;
			if (sec < 60) return `${sec.toFixed(1)}s`;
			const min = sec / 60;
			return `${min.toFixed(1)}m`;
		}

		function savedWorkersGraphLabelColor() {
			const isLight = document.documentElement && document.documentElement.getAttribute('data-theme') === 'light';
			return isLight ? '#4b5568' : '#b3bbd4';
		}

		function savedWorkersGraphGoldColor() {
			const isLight = document.documentElement && document.documentElement.getAttribute('data-theme') === 'light';
			return isLight ? '#8f6a00' : '#f3d36b';
		}

		function formatLatencyPair(p50, p95) {
			const a = Number(p50 || 0);
			const b = Number(p95 || 0);
			if (!isFinite(a) || !isFinite(b) || b <= 0) return 'â€”';
			if (a < 1 && b < 1) return `${Math.max(1, Math.round(a * 1000))}/${Math.max(1, Math.round(b * 1000))}us`;
			if (a < 1000 && b < 1000) return `${Math.round(a)}/${Math.round(b)}ms`;
			const aSec = a / 1000;
			const bSec = b / 1000;
			if (aSec < 60 && bSec < 60) return `${aSec.toFixed(1)}/${bSec.toFixed(1)}s`;
			const aMin = aSec / 60;
			const bMin = bSec / 60;
			return `${aMin.toFixed(1)}/${bMin.toFixed(1)}m`;
		}

		function formatTimeAgo(seconds) {
			const total = Math.max(0, Math.floor(seconds || 0));
			const days = Math.floor(total / 86400);
			const hours = Math.floor((total % 86400) / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			if (days > 0) return `${days}d ${hours}h ago`;
			if (hours > 0) return `${hours}h ${minutes}m ago`;
			return `${Math.max(0, minutes)}m ago`;
		}

		function renderStoredHashrates() {
			const cells = document.querySelectorAll('[data-hashrate]');
			cells.forEach((el) => {
				const value = Number(el.getAttribute('data-hashrate'));
				const accuracy = el.getAttribute('data-hashrate-accuracy');
				el.classList.remove('hashrate-warming', 'hashrate-settling', 'hashrate-solid');
				if (!value) {
					el.textContent = 'â€”';
					return;
				}
				const cls = hashrateClassForAccuracy(accuracy);
				if (cls) el.classList.add(cls);
				el.textContent = formatWorkerHashrate(value, accuracy);
			});
		}

		function renderStoredLatencies() {
			const pairCells = document.querySelectorAll('.latency-pair[data-rtt-p95-ms]');
			pairCells.forEach((el) => {
				const p50 = Number(el.getAttribute('data-rtt-p50-ms') || 0);
				const p95 = Number(el.getAttribute('data-rtt-p95-ms') || 0);
				const raw = p50 > 0 ? p50 : p95;
				el.textContent = formatLatency(raw > 0 ? (raw / 2) : raw);
			});
			const singleCells = document.querySelectorAll('.latency-single[data-latency-ms]');
			singleCells.forEach((el) => {
				el.textContent = formatLatency(el.getAttribute('data-latency-ms'));
			});
		}

		function updateSortOrderButtonText() {
			if (!sortOrderBtn) return;
			sortOrderBtn.textContent = sortDescending ? 'Desc â†“' : 'Asc â†‘';
		}

		function normalizeWorkerDisplayName(value) {
			let raw = String(value || '').trim();
			if (!raw) return 'Unknown';
			raw = raw.replace(/^\.+/, '').trim();
			const dot = raw.indexOf('.');
			if (dot >= 0 && dot < raw.length - 1) {
				raw = raw.slice(dot + 1).trim();
			}
			return raw || 'Unknown';
		}


		function applyWorkerNameDisplay(root) {
			const scope = root || document;
			const workers = scope.querySelectorAll('.worker-link, .sensitive-worker');
			workers.forEach((el) => {
				const name = el.getAttribute('data-worker-name') || '';
				const hash = el.getAttribute('data-worker-hash') || '';
				const display = normalizeWorkerDisplayName(name || hash || String(el.textContent || '').trim() || 'Unknown');
				el.textContent = display;
				el.title = display;
			});
		}

		function applyLastOnlineLabels(root) {
			const scope = root || document;
			const labels = scope.querySelectorAll('.offline-last-online');
			labels.forEach((el) => {
				const raw = el.getAttribute('data-last-online-at') || '';
				const ts = Date.parse(raw);
				if (!isFinite(ts)) {
					el.textContent = '';
					return;
				}
				const seconds = (Date.now() - ts) / 1000;
				el.textContent = `Last online ${formatTimeAgo(seconds)}`;
			});
		}

		function attachRemoveConfirms(root) {
			const scope = root || document;
			const forms = scope.querySelectorAll('form[data-remove-worker]');
			forms.forEach((form) => {
				if (form.__removeConfirmAttached) return;
				form.__removeConfirmAttached = true;
				form.addEventListener('submit', (e) => {
					const name = form.getAttribute('data-remove-worker') || 'this worker';
					if (!confirm(`Remove ${name}?`)) {
						e.preventDefault();
					}
				});
			});
		}

		function attachReconnectConfirms(root) {
			const scope = root || document;
			const forms = scope.querySelectorAll('form[data-reconnect-worker]');
			forms.forEach((form) => {
				if (form.__reconnectConfirmAttached) return;
				form.__reconnectConfirmAttached = true;
				form.addEventListener('submit', (e) => {
					const name = form.getAttribute('data-reconnect-worker') || 'this worker';
					if (!confirm(`Force reset ${name}? This applies a 30s ban, then disconnects active sessions.`)) {
						e.preventDefault();
					}
				});
			});
		}

		function attachNotifyToggles(root) {
			const scope = root || document;
			const toggles = scope.querySelectorAll('.worker-notify-toggle');
			toggles.forEach((btn) => {
				if (btn.__notifyToggleAttached) return;
				btn.__notifyToggleAttached = true;
				btn.addEventListener('click', async () => {
					const hash = btn.getAttribute('data-worker-hash') || '';
					if (!hash) return;
					const current = btn.getAttribute('data-notify-enabled') === '1';
					const next = !current;
					btn.disabled = true;
					try {
						const res = await fetchWithAuthRefresh('/api/saved-workers/notify-enabled', {
							method: 'POST',
							credentials: 'same-origin',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ hash, enabled: next }),
						});
						if (!res.ok) return;
						const data = await res.json();
						const enabled = !!data.enabled;
						btn.setAttribute('data-notify-enabled', enabled ? '1' : '0');
						btn.textContent = notifyToggleText(enabled);
						btn.title = notifyToggleTitle(enabled);
						btn.setAttribute('aria-label', notifyToggleTitle(enabled));
					} catch (_) {
					} finally {
						btn.disabled = false;
					}
				});
			});
		}

		function attachNotifyAllButtons() {
			const btn = document.getElementById('notifyAllToggle');
			if (!btn || btn.__notifyAllAttached) return;
			btn.__notifyAllAttached = true;
			btn.addEventListener('click', async () => {
				const current = btn.getAttribute('data-enabled') === '1';
				const next = !current;
				btn.disabled = true;
				try {
					const res = await fetchWithAuthRefresh('/api/discord/notify-enabled', {
						method: 'POST',
						credentials: 'same-origin',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ enabled: next }),
					});
					if (!res.ok) return;
					const data = await res.json();
					const enabled = !!data.enabled;
					btn.setAttribute('data-enabled', enabled ? '1' : '0');
					btn.textContent = notifyAllToggleText(enabled);
					btn.title = notifyAllToggleTitle(enabled);
					btn.setAttribute('aria-label', notifyAllToggleTitle(enabled));
				} catch (_) {
				} finally {
					btn.disabled = false;
				}
			});
		}

		function setWorkerGraphsStatus(text, danger) {
			if (!workerGraphsStatus) return;
			workerGraphsStatus.textContent = String(text || '');
			workerGraphsStatus.style.color = danger ? '#f88d8d' : 'var(--text-muted)';
		}

		function resizeGraphCanvas(canvas) {
			if (!canvas) return null;
			const dpr = window.devicePixelRatio || 1;
			const rect = canvas.getBoundingClientRect();
			const width = Math.max(10, Math.floor(rect.width || canvas.clientWidth || 10));
			const height = Math.max(10, Math.floor(rect.height || canvas.clientHeight || 10));
			canvas.width = Math.floor(width * dpr);
			canvas.height = Math.floor(height * dpr);
			const ctx = canvas.getContext('2d');
			if (!ctx) return null;
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.scale(dpr, dpr);
			return { ctx, width, height };
		}

		function buildQuantizedBucketRects(xPixelsInput, minBound, maxBound, fallbackWidth) {
			const xPixels = (Array.isArray(xPixelsInput) ? xPixelsInput : [])
				.map((v) => Math.round(Number(v)))
				.filter((v) => Number.isFinite(v));
			const n = xPixels.length;
			const leftBound = Math.max(0, Math.round(Number(minBound) || 0));
			const rightBound = Math.max(leftBound + 1, Math.round(Number(maxBound) || 0));
			if (n === 0) return [];
			if (n === 1) {
				const w = Math.max(1, Math.min(rightBound - leftBound, Math.round(Number(fallbackWidth) || 1)));
				const left = Math.max(leftBound, Math.min(rightBound - w, xPixels[0] - Math.floor(w / 2)));
				return [{ left, width: w, center: xPixels[0] }];
			}

			const edges = new Array(n + 1);
			edges[0] = Math.max(leftBound, Math.round(xPixels[0] - (xPixels[1] - xPixels[0]) / 2));
			for (let i = 1; i < n; i++) {
				edges[i] = Math.round((xPixels[i - 1] + xPixels[i]) / 2);
			}
			edges[n] = Math.min(rightBound, Math.round(xPixels[n - 1] + (xPixels[n - 1] - xPixels[n - 2]) / 2));

			edges[0] = Math.max(leftBound, Math.min(rightBound - n, edges[0]));
			for (let i = 1; i < n; i++) {
				const minEdge = edges[i - 1] + 1;
				const maxEdge = rightBound - (n - i);
				edges[i] = Math.max(minEdge, Math.min(maxEdge, edges[i]));
			}
			edges[n] = rightBound;
			if (edges[n] <= edges[n - 1]) {
				edges[n] = edges[n - 1] + 1;
			}

			const rects = new Array(n);
			for (let i = 0; i < n; i++) {
				const left = edges[i];
				const right = Math.max(left + 1, edges[i + 1]);
				rects[i] = {
					left,
					width: right - left,
					center: xPixels[i],
				};
			}
			return rects;
		}

		function getSavedWorkersTopChartHashes() {
			const hashes = new Set();
			for (const w of (Array.isArray(lastOnlineWorkers) ? lastOnlineWorkers : [])) {
				const hash = String(w?.hash || '').trim().toLowerCase();
				if (hash) hashes.add(hash);
			}
			return hashes;
		}

		function aggregateSavedWorkersTopChartSeries() {
			const hashes = getSavedWorkersTopChartHashes();
			const hashrateByTs = new Map();
			const bestByTs = new Map();
			let cachedWorkers = 0;
			for (const hash of hashes) {
				const cached = inlineWorkerChartCache.get(hash);
				if (!cached) continue;
				let used = false;
				const hashrateRows = Array.isArray(cached?.hashrateRows?.rows) ? cached.hashrateRows.rows : [];
				for (const row of hashrateRows) {
					const ts = Number(row?.at);
					const value = Number(row?.value);
					if (!Number.isFinite(ts) || !Number.isFinite(value) || value < 0) continue;
					hashrateByTs.set(ts, (hashrateByTs.get(ts) || 0) + value);
					used = true;
				}
				const bestRows = Array.isArray(cached?.bestRows?.rows) ? cached.bestRows.rows : [];
				for (const row of bestRows) {
					const ts = Number(row?.at);
					const value = Number(row?.value);
					if (!Number.isFinite(ts) || !Number.isFinite(value) || value < 0) continue;
					bestByTs.set(ts, Math.max(bestByTs.get(ts) || 0, value));
					used = true;
				}
				if (used) cachedWorkers++;
			}

			const outHashrateRows = Array.from(hashrateByTs.entries())
				.map(([at, value]) => ({ at, value }))
				.sort((a, b) => a.at - b.at);
			const outBestRows = Array.from(bestByTs.entries())
				.map(([at, value]) => ({ at, value }))
				.sort((a, b) => a.at - b.at);

			if (savedWorkersTopChartLiveAt > 0 && Number.isFinite(savedWorkersTopChartLiveHashrate)) {
				const lastTs = outHashrateRows.length > 0 ? Number(outHashrateRows[outHashrateRows.length - 1].at || 0) : 0;
				if (!(lastTs > 0) || savedWorkersTopChartLiveAt > lastTs) {
					outHashrateRows.push({
						at: savedWorkersTopChartLiveAt,
						value: Math.max(0, Number(savedWorkersTopChartLiveHashrate || 0)),
					});
				}
			}

			return {
				hashrateRows: outHashrateRows,
				bestRows: outBestRows,
				workerCount: hashes.size,
				cachedWorkers,
			};
		}

		function drawSavedWorkersTopChart() {
			if (!(savedWorkersTopChartCanvas instanceof HTMLCanvasElement)) return;
			const resized = resizeGraphCanvas(savedWorkersTopChartCanvas);
			if (!resized) return;
			const { ctx, width, height } = resized;
			ctx.clearRect(0, 0, width, height);

			const series = aggregateSavedWorkersTopChartSeries();
			const hashrateRows = Array.isArray(series?.hashrateRows) ? series.hashrateRows : [];
			const bestRows = Array.isArray(series?.bestRows) ? series.bestRows : [];
			if (savedWorkersTopChartMeta) {
				savedWorkersTopChartMeta.textContent = 'Blue bars: total hashrate. Gold line: best share.';
			}

			const allRows = hashrateRows.concat(bestRows);
			if (allRows.length === 0) {
				ctx.fillStyle = savedWorkersGraphLabelColor();
				ctx.font = '13px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('Waiting for saved worker history...', width / 2, height / 2);
				return;
			}

			const paddingLeft = 82;
			const paddingRight = 82;
			const paddingTop = 14;
			const paddingBottom = 24;
			const graphWidth = Math.max(10, width - paddingLeft - paddingRight);
			const graphHeight = Math.max(10, height - paddingTop - paddingBottom);

			let minX = Number.POSITIVE_INFINITY;
			let maxX = 0;
			for (const row of allRows) {
				const at = Number(row?.at);
				if (!Number.isFinite(at)) continue;
				if (at < minX) minX = at;
				if (at > maxX) maxX = at;
			}
			if (!Number.isFinite(minX)) minX = Date.now();
			if (!(maxX > minX)) maxX = minX + 1;
			const spanX = Math.max(1, maxX - minX);

			let maxHashrate = 0;
			for (const row of hashrateRows) {
				const value = Number(row?.value || 0);
				if (Number.isFinite(value) && value > maxHashrate) maxHashrate = value;
			}
			let maxBest = 0;
			for (const row of bestRows) {
				const value = Number(row?.value || 0);
				if (Number.isFinite(value) && value > maxBest) maxBest = value;
			}
			maxHashrate = Math.max(1, maxHashrate * 1.25);
			maxBest = Math.max(1, maxBest * 1.25);

			const xFor = (at) => paddingLeft + ((at - minX) / spanX) * graphWidth;
			const yHashFor = (value) => paddingTop + graphHeight * (1 - (Math.max(0, value) / maxHashrate));
			const yBestFor = (value) => paddingTop + graphHeight * (1 - (Math.max(0, value) / maxBest));
			const px = (value) => Math.round(value);
			const baselineY = px(height - paddingBottom);

			ctx.strokeStyle = '#2a2f3a';
			ctx.lineWidth = 1;
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				ctx.beginPath();
				ctx.moveTo(paddingLeft, y);
				ctx.lineTo(width - paddingRight, y);
				ctx.stroke();
			}

			ctx.fillStyle = savedWorkersGraphLabelColor();
			ctx.font = '10px monospace';
			ctx.textAlign = 'right';
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				const value = maxHashrate - (maxHashrate * i / 4);
				let label = formatHashrate(value);
				if ((label === 'â€”' || label === '---') && value <= 0) label = '0';
				ctx.fillText(label, paddingLeft - 6, y + 3);
			}
			ctx.textAlign = 'left';
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				const value = maxBest - (maxBest * i / 4);
				ctx.fillText(formatDifficultyGraph(value), width - paddingRight + 6, y + 3);
			}

			const hRects = buildQuantizedBucketRects(
				hashrateRows.map((row) => xFor(row.at)),
				paddingLeft,
				width - paddingRight,
				Math.max(2, Math.ceil(graphWidth / 32)),
			);
			const fallbackBarW = hRects.length > 0 ? hRects[0].width : Math.max(2, Math.ceil(graphWidth / 32));

			ctx.fillStyle = 'rgba(74, 158, 255, 0.45)';
			for (let i = 0; i < hashrateRows.length; i++) {
				const row = hashrateRows[i];
				const rect = hRects[i];
				if (!rect) continue;
				const left = rect.left;
				const barW = rect.width;
				const top = px(Math.max(paddingTop, Math.min(baselineY, yHashFor(Number(row.value || 0)))));
				let h = baselineY - top;
				if (h <= 0) h = 1;
				ctx.fillRect(left, baselineY - h, barW, h);
			}

			if (bestRows.length > 0) {
				ctx.strokeStyle = savedWorkersGraphGoldColor();
				ctx.lineWidth = 2;
				const bRects = buildQuantizedBucketRects(
					bestRows.map((row) => xFor(row.at)),
					paddingLeft,
					width - paddingRight,
					Math.max(4, fallbackBarW),
				);
				for (let i = 0; i < bestRows.length; i++) {
					const row = bestRows[i];
					const rect = bRects[i];
					if (!rect) continue;
					const y = px(yBestFor(Number(row.value || 0)));
					const left = rect.left;
					const right = left + rect.width;
					ctx.beginPath();
					ctx.moveTo(left, y);
					ctx.lineTo(right, y);
					ctx.stroke();
				}
			}

			ctx.strokeStyle = '#ffffff';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(paddingLeft, height - paddingBottom);
			ctx.lineTo(width - paddingRight, height - paddingBottom);
			ctx.stroke();

			ctx.fillStyle = savedWorkersGraphLabelColor();
			ctx.textAlign = 'center';
			ctx.font = '10px monospace';
			ctx.fillText(`time: ${formatGraphTimeSpan((maxX - minX) / 1000)}`, paddingLeft + graphWidth / 2, height - 6);
		}

		function updateSavedWorkersTopChartLiveHashrate(hashrate) {
			const value = Number(hashrate || 0);
			savedWorkersTopChartLiveHashrate = Number.isFinite(value) ? Math.max(0, value) : 0;
			savedWorkersTopChartLiveAt = Date.now();
			drawSavedWorkersTopChart();
		}

		function drawWorkerCombinedHistoryGraph(canvas, hashrateRowsInput, bestRowsInput) {
			if (!(canvas instanceof HTMLCanvasElement)) return;
			const resized = resizeGraphCanvas(canvas);
			if (!resized) return;
			const { ctx, width, height } = resized;
			ctx.clearRect(0, 0, width, height);

			const hashrateRows = (Array.isArray(hashrateRowsInput?.rows) ? hashrateRowsInput.rows : (Array.isArray(hashrateRowsInput) ? hashrateRowsInput : []))
				.map((r) => ({ at: Number(r?.at), value: Number(r?.value || 0) }))
				.filter((r) => Number.isFinite(r.at) && Number.isFinite(r.value) && r.value >= 0)
				.sort((a, b) => a.at - b.at);
			const bestRows = (Array.isArray(bestRowsInput?.rows) ? bestRowsInput.rows : (Array.isArray(bestRowsInput) ? bestRowsInput : []))
				.map((r) => ({ at: Number(r?.at), value: Number(r?.value || 0) }))
				.filter((r) => Number.isFinite(r.at) && Number.isFinite(r.value) && r.value >= 0)
				.sort((a, b) => a.at - b.at);
			const allRows = hashrateRows.concat(bestRows);
			if (allRows.length === 0) {
				ctx.fillStyle = savedWorkersGraphLabelColor();
				ctx.font = '13px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('No data yet', width / 2, height / 2);
				return;
			}

			const paddingLeft = 82;
			const paddingRight = 82;
			const paddingTop = 14;
			const paddingBottom = 24;
			const graphWidth = Math.max(10, width - paddingLeft - paddingRight);
			const graphHeight = Math.max(10, height - paddingTop - paddingBottom);

			let minX = Number.POSITIVE_INFINITY;
			let maxX = 0;
			for (const row of allRows) {
				if (row.at < minX) minX = row.at;
				if (row.at > maxX) maxX = row.at;
			}
			if (!Number.isFinite(minX)) minX = Date.now();
			if (!(maxX > minX)) maxX = minX + 1;
			const spanX = Math.max(1, maxX - minX);

			let maxHashrate = 0;
			for (const row of hashrateRows) if (row.value > maxHashrate) maxHashrate = row.value;
			let maxBest = 0;
			for (const row of bestRows) if (row.value > maxBest) maxBest = row.value;
			maxHashrate = Math.max(1, maxHashrate * 1.25);
			maxBest = Math.max(1, maxBest * 1.25);

			const xFor = (at) => paddingLeft + ((at - minX) / spanX) * graphWidth;
			const yHashFor = (value) => paddingTop + graphHeight * (1 - (Math.max(0, value) / maxHashrate));
			const yBestFor = (value) => paddingTop + graphHeight * (1 - (Math.max(0, value) / maxBest));
			const px = (value) => Math.round(value);
			const baselineY = px(height - paddingBottom);

			ctx.strokeStyle = '#2a2f3a';
			ctx.lineWidth = 1;
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				ctx.beginPath();
				ctx.moveTo(paddingLeft, y);
				ctx.lineTo(width - paddingRight, y);
				ctx.stroke();
			}

			ctx.fillStyle = savedWorkersGraphLabelColor();
			ctx.font = '10px monospace';
			ctx.textAlign = 'right';
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				const value = maxHashrate - (maxHashrate * i / 4);
				let label = formatHashrate(value);
				if ((label === 'â€”' || label === '---') && value <= 0) label = '0';
				ctx.fillText(label, paddingLeft - 6, y + 3);
			}
			ctx.textAlign = 'left';
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				const value = maxBest - (maxBest * i / 4);
				ctx.fillText(formatDifficultyGraph(value), width - paddingRight + 6, y + 3);
			}

			const hRects = buildQuantizedBucketRects(
				hashrateRows.map((row) => xFor(row.at)),
				paddingLeft,
				width - paddingRight,
				Math.max(2, Math.ceil(graphWidth / 32)),
			);
			const fallbackBarW = hRects.length > 0 ? hRects[0].width : Math.max(2, Math.ceil(graphWidth / 32));

			ctx.fillStyle = 'rgba(74, 158, 255, 0.45)';
			for (let i = 0; i < hashrateRows.length; i++) {
				const row = hashrateRows[i];
				const rect = hRects[i];
				if (!rect) continue;
				const top = px(Math.max(paddingTop, Math.min(baselineY, yHashFor(row.value))));
				let h = baselineY - top;
				if (h <= 0) h = 1;
				ctx.fillRect(rect.left, baselineY - h, rect.width, h);
			}

			const bRects = buildQuantizedBucketRects(
				bestRows.map((row) => xFor(row.at)),
				paddingLeft,
				width - paddingRight,
				Math.max(4, fallbackBarW),
			);
			ctx.strokeStyle = savedWorkersGraphGoldColor();
			ctx.lineWidth = 2;
			for (let i = 0; i < bestRows.length; i++) {
				const row = bestRows[i];
				const rect = bRects[i];
				if (!rect) continue;
				const y = px(yBestFor(row.value));
				ctx.beginPath();
				ctx.moveTo(rect.left, y);
				ctx.lineTo(rect.left + rect.width, y);
				ctx.stroke();
			}

			ctx.strokeStyle = '#ffffff';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(paddingLeft, height - paddingBottom);
			ctx.lineTo(width - paddingRight, height - paddingBottom);
			ctx.stroke();
			ctx.fillStyle = savedWorkersGraphLabelColor();
			ctx.textAlign = 'center';
			ctx.font = '10px monospace';
			ctx.fillText(`time: ${formatGraphTimeSpan((maxX - minX) / 1000)}`, paddingLeft + graphWidth / 2, height - 6);
		}

		function drawWorkerSeriesGraph(canvas, rowsInput, color, valueFormatter) {
			const resized = resizeGraphCanvas(canvas);
			if (!resized) return;
			const { ctx, width, height } = resized;
			ctx.clearRect(0, 0, width, height);
			const paddingLeft = 72;
			const paddingRight = 14;
			const paddingTop = 14;
			const paddingBottom = 24;
			const graphWidth = Math.max(10, width - paddingLeft - paddingRight);
			const graphHeight = Math.max(10, height - paddingTop - paddingBottom);

			const rowsSource = Array.isArray(rowsInput) ? { rows: rowsInput } : (rowsInput || {});
			const rows = (Array.isArray(rowsSource.rows) ? rowsSource.rows : [])
				.map((p) => ({
					at: (typeof p?.at === 'number') ? p.at : Date.parse(p?.at),
					value: Number(p?.value ?? 0),
				}))
				.filter((p) => Number.isFinite(p.at) && Number.isFinite(p.value) && p.value >= 0)
				.sort((a, b) => a.at - b.at);
			const maxVisibleRows = Math.max(1, Math.floor(graphWidth));
			const visibleRows = rows.length > maxVisibleRows ? rows.slice(rows.length - maxVisibleRows) : rows;

			if (visibleRows.length === 0) {
				ctx.fillStyle = '#b3bbd4';
				ctx.font = '13px monospace';
				ctx.textAlign = 'center';
				ctx.fillText('No data yet', width / 2, height / 2);
				return;
			}

			const minX = visibleRows[0].at;
			const maxX = visibleRows[visibleRows.length - 1].at;
			const spanX = Math.max(1, maxX - minX);
			let minY = 0;
			let visibleMaxY = 0;
			for (const r of visibleRows) {
				if (r.value > visibleMaxY) visibleMaxY = r.value;
			}
			let maxY = visibleMaxY > 0 ? (visibleMaxY * 1.25) : 1;
			const spanY = Math.max(1e-9, maxY - minY);

			ctx.strokeStyle = '#2a2f3a';
			ctx.lineWidth = 1;
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				ctx.beginPath();
				ctx.moveTo(paddingLeft, y);
				ctx.lineTo(width - paddingRight, y);
				ctx.stroke();
			}

			ctx.fillStyle = '#b3bbd4';
			ctx.font = '10px monospace';
			ctx.textAlign = 'right';
			for (let i = 0; i <= 4; i++) {
				const y = paddingTop + (graphHeight * i / 4);
				const v = maxY - (spanY * i / 4);
				let label = String(valueFormatter(v) ?? '');
				if ((label === 'â€”' || label === '-' || label === '---') && v <= 0) {
					label = '0';
				}
				ctx.fillText(label, paddingLeft - 6, y + 3);
			}

			const xFor = (at) => paddingLeft + ((at - minX) / spanX) * graphWidth;
			const yFor = (v) => paddingTop + graphHeight * (1 - ((v - minY) / spanY));
			const px = (v) => Math.round(v);
			const findStepMillis = () => {
				let step = 0;
				for (let i = 1; i < visibleRows.length; i++) {
					const d = visibleRows[i].at - visibleRows[i - 1].at;
					if (!(d > 0)) continue;
					if (!(step > 0) || d < step) step = d;
				}
				return step > 0 ? step : 0;
			};
			const stepMillis = findStepMillis();
			let barW = 3;
			if (visibleRows.length > 1 && stepMillis > 0) {
				const dx = Math.abs(xFor(minX + stepMillis) - xFor(minX));
				barW = Math.max(1, Math.ceil(dx));
			} else if (visibleRows.length > 0) {
				barW = Math.max(1, Math.ceil(graphWidth / Math.max(1, visibleRows.length)));
			}
			if (barW > graphWidth) barW = graphWidth;
			const baselineY = px(height - paddingBottom);

			ctx.fillStyle = color;
			for (const r of visibleRows) {
				const xc = px(xFor(r.at));
				const left = Math.max(paddingLeft, xc - Math.floor(barW / 2));
				const top = px(Math.max(paddingTop, Math.min(baselineY, yFor(r.value))));
				let h = baselineY - top;
				// Render present zero buckets as a 1px baseline bar so offline gaps
				// remain visible after zero-gap backfill.
				if (h <= 0) h = 1;
				ctx.fillRect(left, baselineY - h, barW, h);
			}

			ctx.strokeStyle = '#ffffff';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(paddingLeft, height - paddingBottom);
			ctx.lineTo(width - paddingRight, height - paddingBottom);
			ctx.stroke();
			ctx.fillStyle = '#b3bbd4';
			ctx.textAlign = 'center';
			ctx.fillText(`time: ${formatGraphTimeSpan((maxX - minX) / 1000)}`, paddingLeft + graphWidth / 2, height - 6);
		}

		function bitIsSet(bytes, idx) {
			if (!Array.isArray(bytes) || idx < 0) return false;
			const bi = Math.floor(idx / 8);
			if (bi < 0 || bi >= bytes.length) return false;
			const b = Number(bytes[bi] || 0);
			return ((b >> (idx % 8)) & 1) === 1;
		}

		function decodeByteSeries(value) {
			if (Array.isArray(value)) return value;
			if (typeof value !== 'string' || !value) return [];
			try {
				const raw = atob(value);
				const out = new Array(raw.length);
				for (let i = 0; i < raw.length; i++) {
					out[i] = raw.charCodeAt(i) & 255;
				}
				return out;
			} catch (_) {
				return [];
			}
		}

		function dequantizeQ8(q, minV, maxV) {
			const qq = Number(q || 0);
			const lo = Number(minV || 0);
			const hi = Number(maxV || 0);
			if (!isFinite(qq) || qq < 0) return lo;
			if (!isFinite(lo) || !isFinite(hi)) return 0;
			if (!(hi > lo)) return lo;
			return lo + (Math.max(0, Math.min(255, qq)) / 255) * (hi - lo);
		}

		function decodeCompactWorkerSeries(data, qKey, minKey, maxKey) {
			const count = Math.max(0, Number(data?.n || 0));
			const startMinute = Math.max(0, Number(data?.s || 0));
			const intervalSec = Math.max(1, Number(data?.i || 60));
			const intervalMillis = intervalSec * 1000;
			const present = decodeByteSeries(data?.p);
			const q = decodeByteSeries(data?.[qKey]);
			const minV = Number(data?.[minKey] || 0);
			const maxV = Number(data?.[maxKey] || 0);
			const rows = [];
			for (let i = 0; i < count; i++) {
				if (!bitIsSet(present, i)) continue;
				const tsMillis = (startMinute * 60 * 1000) + (i * intervalMillis);
				rows.push({
					at: tsMillis,
					value: dequantizeQ8(q[i], minV, maxV),
				});
			}
			return {
				rows,
				min: minV,
				max: maxV,
				intervalMillis,
			};
		}

		function computeWorkerHistoryUptimePercentFromCompact(data) {
			const count = Math.max(0, Number(data?.n || 0));
			if (count <= 0) return null;
			const present = decodeByteSeries(data?.p);
			const hq = decodeByteSeries(data?.hq);
			const bq = decodeByteSeries(data?.bq);
			let total = 0;
			let online = 0;
			for (let i = 0; i < count; i++) {
				if (!bitIsSet(present, i)) continue;
				total++;
				const h = Number(hq[i] || 0);
				const b = Number(bq[i] || 0);
				if (h > 0 || b > 0) online++;
			}
			if (total <= 0) return null;
			return (online / total) * 100;
		}

		function drawInlineSparkline(canvas, rows, color) {
			if (!(canvas instanceof HTMLCanvasElement)) return;
			const dpr = window.devicePixelRatio || 1;
			const cssW = Math.max(20, canvas.clientWidth || 120);
			const cssH = Math.max(8, canvas.clientHeight || 14);
			canvas.width = Math.floor(cssW * dpr);
			canvas.height = Math.floor(cssH * dpr);
			const ctx = canvas.getContext('2d');
			if (!ctx) return;
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.scale(dpr, dpr);
			ctx.clearRect(0, 0, cssW, cssH);

			const points = (Array.isArray(rows) ? rows : [])
				.map((r) => ({ x: Number(r?.at), y: Number(r?.value) }))
				.filter((r) => Number.isFinite(r.x) && Number.isFinite(r.y) && r.y >= 0)
				.sort((a, b) => a.x - b.x);
			const maxVisiblePoints = Math.max(1, Math.floor(cssW));
			const visiblePoints = points.length > maxVisiblePoints ? points.slice(points.length - maxVisiblePoints) : points;
			if (visiblePoints.length === 0) {
				ctx.strokeStyle = '#2a2f3a';
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(0, cssH - 1);
				ctx.lineTo(cssW, cssH - 1);
				ctx.stroke();
				return;
			}

			let minX = visiblePoints[0].x;
			let maxX = visiblePoints[visiblePoints.length - 1].x;
			if (!(maxX > minX)) maxX = minX + 1;
			let maxY = 0;
			for (const p of visiblePoints) {
				if (p.y > maxY) maxY = p.y;
			}
			maxY = maxY > 0 ? (maxY * 1.25) : 1;
			const pad = 1;
			const xFor = (x) => pad + ((x - minX) / (maxX - minX)) * (cssW - pad*2);
			const yFor = (y) => cssH - pad - (y / maxY) * (cssH - pad*2);
			const px = (v) => Math.round(v);
			let stepX = 0;
			for (let i = 1; i < visiblePoints.length; i++) {
				const d = visiblePoints[i].x - visiblePoints[i - 1].x;
				if (!(d > 0)) continue;
				const dx = Math.abs(xFor(visiblePoints[i].x) - xFor(visiblePoints[i - 1].x));
				if (!(stepX > 0) || dx < stepX) stepX = dx;
			}
			let barW = Math.max(1, Math.ceil(stepX > 0 ? stepX : (cssW / Math.max(1, visiblePoints.length))));
			if (barW > cssW) barW = Math.floor(cssW);
			const baselineY = px(cssH - 1);

			ctx.strokeStyle = '#2a2f3a';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(0, cssH - 1);
			ctx.lineTo(cssW, cssH - 1);
			ctx.stroke();

			ctx.fillStyle = color;
			for (let i = 0; i < visiblePoints.length; i++) {
				const p = visiblePoints[i];
				const xc = px(xFor(p.x));
				const left = Math.max(0, Math.min(cssW - barW, xc - Math.floor(barW / 2)));
				const top = px(Math.max(0, Math.min(baselineY, yFor(p.y))));
				let h = baselineY - top;
				if (h <= 0) h = 1;
				ctx.fillRect(left, baselineY - h, barW, h);
			}
		}

		function drawInlineCombinedSparkline(canvas, hashrateRowsInput, bestRowsInput) {
			if (!(canvas instanceof HTMLCanvasElement)) return;
			const dpr = window.devicePixelRatio || 1;
			const cssW = Math.max(24, canvas.clientWidth || 128);
			const cssH = Math.max(10, canvas.clientHeight || 16);
			canvas.width = Math.floor(cssW * dpr);
			canvas.height = Math.floor(cssH * dpr);
			const ctx = canvas.getContext('2d');
			if (!ctx) return;
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.scale(dpr, dpr);
			ctx.clearRect(0, 0, cssW, cssH);

			const toPoints = (rows) => (Array.isArray(rows) ? rows : [])
				.map((r) => ({ x: Number(r?.at), y: Number(r?.value) }))
				.filter((r) => Number.isFinite(r.x) && Number.isFinite(r.y) && r.y >= 0)
				.sort((a, b) => a.x - b.x);
			const hPointsRaw = toPoints(hashrateRowsInput);
			const bPointsRaw = toPoints(bestRowsInput);
			const maxVisiblePoints = Math.max(1, Math.floor(cssW));
			const hPoints = hPointsRaw.length > maxVisiblePoints ? hPointsRaw.slice(hPointsRaw.length - maxVisiblePoints) : hPointsRaw;
			const bPoints = bPointsRaw.length > maxVisiblePoints ? bPointsRaw.slice(bPointsRaw.length - maxVisiblePoints) : bPointsRaw;

			if (hPoints.length === 0 && bPoints.length === 0) {
				ctx.strokeStyle = '#2a2f3a';
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(0, cssH - 1);
				ctx.lineTo(cssW, cssH - 1);
				ctx.stroke();
				return;
			}

			let minX = Number.POSITIVE_INFINITY;
			let maxX = 0;
			for (const p of hPoints.concat(bPoints)) {
				if (p.x < minX) minX = p.x;
				if (p.x > maxX) maxX = p.x;
			}
			if (!Number.isFinite(minX)) minX = 0;
			if (!(maxX > minX)) maxX = minX + 1;

			let maxHash = 0;
			for (const p of hPoints) if (p.y > maxHash) maxHash = p.y;
			let maxBest = 0;
			for (const p of bPoints) if (p.y > maxBest) maxBest = p.y;
			maxHash = maxHash > 0 ? maxHash * 1.25 : 1;
			maxBest = maxBest > 0 ? maxBest * 1.25 : 1;

			const pad = 1;
			const spanX = Math.max(1, maxX - minX);
			const xFor = (x) => pad + ((x - minX) / spanX) * (cssW - pad * 2);
			const yHashFor = (y) => cssH - pad - (Math.max(0, y) / maxHash) * (cssH - pad * 2);
			const yBestFor = (y) => cssH - pad - (Math.max(0, y) / maxBest) * (cssH - pad * 2);
			const px = (v) => Math.round(v);
			const baselineY = px(cssH - 1);

			const hRects = buildQuantizedBucketRects(
				hPoints.map((p) => xFor(p.x)),
				0,
				cssW,
				Math.max(2, Math.ceil(cssW / Math.max(1, hPoints.length || bPoints.length || 1))),
			);
			const bRects = buildQuantizedBucketRects(
				bPoints.map((p) => xFor(p.x)),
				0,
				cssW,
				Math.max(3, (hRects[0]?.width || 3)),
			);

			ctx.strokeStyle = '#2a2f3a';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(0, cssH - 1);
			ctx.lineTo(cssW, cssH - 1);
			ctx.stroke();

			ctx.fillStyle = 'rgba(74, 158, 255, 0.55)';
			for (let i = 0; i < hPoints.length; i++) {
				const p = hPoints[i];
				const rect = hRects[i];
				if (!rect) continue;
				const left = rect.left;
				const barW = rect.width;
				const top = px(Math.max(0, Math.min(baselineY, yHashFor(p.y))));
				let h = baselineY - top;
				if (h <= 0) h = 1;
				ctx.fillRect(left, baselineY - h, barW, h);
			}

			ctx.strokeStyle = '#f3d36b';
			ctx.lineWidth = 2;
			for (let i = 0; i < bPoints.length; i++) {
				const p = bPoints[i];
				const rect = bRects[i];
				if (!rect) continue;
				const y = px(Math.max(0, Math.min(baselineY, yBestFor(p.y))));
				const left = rect.left;
				const right = left + rect.width;
				ctx.beginPath();
				ctx.moveTo(left, y);
				ctx.lineTo(right, y);
				ctx.stroke();
			}
		}

		function renderInlineWorkerSparklinesFromCache(root) {
			const scope = root || document;
			const canvases = scope.querySelectorAll('canvas[data-worker-inline-chart][data-worker-hash]');
			canvases.forEach((canvas) => {
				const hash = String(canvas.getAttribute('data-worker-hash') || '').trim().toLowerCase();
				if (!hash) return;
				const kind = String(canvas.getAttribute('data-worker-inline-chart') || '').trim().toLowerCase();
				const cached = inlineWorkerChartCache.get(hash);
				const hashrateRows = Array.isArray(cached?.hashrateRows?.rows) ? cached.hashrateRows.rows : [];
				const bestRows = Array.isArray(cached?.bestRows?.rows) ? cached.bestRows.rows : [];
				if (kind === 'combined') {
					drawInlineCombinedSparkline(canvas, hashrateRows, bestRows);
					return;
				}
				const series = kind === 'bestshare' ? bestRows : hashrateRows;
				const color = kind === 'bestshare' ? '#f3d36b' : '#4a9eff';
				drawInlineSparkline(canvas, series, color);
			});
			renderInlineWorkerUptimeFromCache(scope);
		}

		function computeWorkerHistoryUptimePercent(cached) {
			const hRows = Array.isArray(cached?.hashrateRows?.rows) ? cached.hashrateRows.rows : [];
			const bRows = Array.isArray(cached?.bestRows?.rows) ? cached.bestRows.rows : [];
			if (hRows.length === 0 && bRows.length === 0) {
				if (Number.isFinite(cached?.historyUptimePercent)) {
					return Number(cached.historyUptimePercent);
				}
				return null;
			}
			const intervalMillis = Math.max(
				1,
				Number(cached?.hashrateRows?.intervalMillis || 0) || 0,
				Number(cached?.bestRows?.intervalMillis || 0) || 0,
			) || 60000;
			const byTs = new Map();
			let minTs = Number.POSITIVE_INFINITY;
			let maxTs = 0;
			for (const r of hRows) {
				const ts = Number(r?.at);
				if (!Number.isFinite(ts)) continue;
				const rec = byTs.get(ts) || { h: 0, b: 0 };
				rec.h = Math.max(Number(rec.h || 0), Number(r?.value || 0));
				byTs.set(ts, rec);
				if (ts < minTs) minTs = ts;
				if (ts > maxTs) maxTs = ts;
			}
			for (const r of bRows) {
				const ts = Number(r?.at);
				if (!Number.isFinite(ts)) continue;
				const rec = byTs.get(ts) || { h: 0, b: 0 };
				rec.b = Math.max(Number(rec.b || 0), Number(r?.value || 0));
				byTs.set(ts, rec);
				if (ts < minTs) minTs = ts;
				if (ts > maxTs) maxTs = ts;
			}
			if (byTs.size === 0) return null;
			let online = 0;
			for (const rec of byTs.values()) {
				if (Number(rec.h) > 0 || Number(rec.b) > 0) online++;
			}
			let total = byTs.size;
			if (Number.isFinite(minTs) && Number.isFinite(maxTs) && maxTs >= minTs) {
				total = Math.max(total, Math.floor(((maxTs - minTs) / intervalMillis) + 1));
			}
			return (online / Math.max(1, total)) * 100;
		}

		function formatHistoryUptimePercent(value) {
			const v = Number(value);
			if (!Number.isFinite(v) || v < 0) return 'â€”';
			return `${Math.max(0, Math.min(100, v)).toFixed(2)}%`;
		}

		function renderInlineWorkerUptimeFromCache(root) {
			const scope = root || document;
			const els = scope.querySelectorAll('[data-worker-uptime-history]');
			els.forEach((el) => {
				const hash = String(el.getAttribute('data-worker-uptime-history') || '').trim().toLowerCase();
				if (!hash) return;
				const cached = inlineWorkerChartCache.get(hash);
				el.textContent = formatHistoryUptimePercent(computeWorkerHistoryUptimePercent(cached));
			});
		}

		async function fetchInlineWorkerSparkline(hash) {
			hash = String(hash || '').trim().toLowerCase();
			if (!hash) return;
			const cached = inlineWorkerChartCache.get(hash);
			const now = Date.now();
			if (cached?.inFlight) return;
			if (cached && Number.isFinite(cached.fetchedAt) && (now - cached.fetchedAt) < inlineWorkerChartRefreshMS) {
				return;
			}
			inlineWorkerChartCache.set(hash, { ...(cached || {}), inFlight: true, fetchedAt: cached?.fetchedAt || 0 });
			try {
				const res = await fetchWithAuthRefresh(`/api/saved-workers/history?hash=${encodeURIComponent(hash)}`, { credentials: 'same-origin' });
				if (!res.ok) throw new Error(`http ${res.status}`);
				const data = await res.json();
				inlineWorkerChartCache.set(hash, {
					inFlight: false,
					fetchedAt: now,
					hashrateRows: decodeCompactWorkerSeries(data, 'hq', 'h0', 'h1'),
					bestRows: decodeCompactWorkerSeries(data, 'bq', 'b0', 'b1'),
					historyUptimePercent: computeWorkerHistoryUptimePercentFromCompact(data),
				});
				drawSavedWorkersTopChart();
			} catch (err) {
				console.error('inline worker sparkline fetch failed', err);
				inlineWorkerChartCache.set(hash, { ...(cached || {}), inFlight: false, fetchedAt: now });
			}
		}

		function refreshInlineWorkerSparklines(root) {
			const scope = root || document;
			const canvases = scope.querySelectorAll('canvas[data-worker-inline-chart][data-worker-hash]');
			const hashes = new Set();
			canvases.forEach((canvas) => {
				const hash = String(canvas.getAttribute('data-worker-hash') || '').trim().toLowerCase();
				if (hash) hashes.add(hash);
			});
			renderInlineWorkerSparklinesFromCache(scope);
			hashes.forEach((hash) => {
				fetchInlineWorkerSparkline(hash).finally(() => renderInlineWorkerSparklinesFromCache(scope));
			});
		}

		async function openWorkerGraphs(hash, name) {
			hash = String(hash || '').trim().toLowerCase();
			if (!hash) return;
			if (workerGraphsTitle) workerGraphsTitle.textContent = 'Worker history';
			if (workerGraphsSubtitle) {
				workerGraphsSubtitle.setAttribute('data-worker-name', String(name || ''));
				workerGraphsSubtitle.setAttribute('data-worker-hash', hash);
				applyWorkerNameDisplay(workerGraphsSubtitle.parentElement || workerGraphsSubtitle);
			}
			setWorkerGraphsStatus('Loading history...', false);
			drawWorkerCombinedHistoryGraph(workerGraphsCombinedCanvas, [], []);
			try {
				if (workerGraphsDialog) {
					if (typeof workerGraphsDialog.showModal === 'function') workerGraphsDialog.showModal();
					else workerGraphsDialog.setAttribute('open', '');
				}
			} catch (_) {
				if (workerGraphsDialog) workerGraphsDialog.setAttribute('open', '');
			}
			try {
				const res = await fetchWithAuthRefresh(`/api/saved-workers/history?hash=${encodeURIComponent(hash)}`, { credentials: 'same-origin' });
				if (!res.ok) throw new Error(`http ${res.status}`);
				const data = await res.json();
				const hashrateRows = decodeCompactWorkerSeries(data, 'hq', 'h0', 'h1');
				const bestRows = decodeCompactWorkerSeries(data, 'bq', 'b0', 'b1');
				const fetchedAt = Date.now();
				inlineWorkerChartCache.set(hash, {
					...(inlineWorkerChartCache.get(hash) || {}),
					inFlight: false,
					fetchedAt,
					hashrateRows,
					bestRows,
					historyUptimePercent: computeWorkerHistoryUptimePercentFromCompact(data),
				});
				drawSavedWorkersTopChart();
				renderInlineWorkerSparklinesFromCache(document);
				const labelName = String(data?.name || name || '').trim();
				if (workerGraphsSubtitle) {
					workerGraphsSubtitle.setAttribute('data-worker-name', labelName);
					workerGraphsSubtitle.setAttribute('data-worker-hash', hash);
					applyWorkerNameDisplay(workerGraphsSubtitle.parentElement || workerGraphsSubtitle);
				}
				drawWorkerCombinedHistoryGraph(workerGraphsCombinedCanvas, hashrateRows, bestRows);
				const shown = Math.max(hashrateRows.length, bestRows.length);
				setWorkerGraphsStatus(shown > 0 ? `Showing ${shown} bucket${shown === 1 ? '' : 's'} (2m).` : 'No history recorded yet for this saved worker.', false);
			} catch (err) {
				console.error('worker history fetch failed', err);
				setWorkerGraphsStatus('Failed to load history.', true);
			}
		}

		function attachWorkerGraphButtons(root) {
			const scope = root || document;
			const buttons = scope.querySelectorAll('.worker-history-open');
			buttons.forEach((btn) => {
				if (btn.__workerGraphsAttached) return;
				btn.__workerGraphsAttached = true;
				btn.addEventListener('click', async () => {
					const hash = btn.getAttribute('data-worker-hash') || '';
					const name = btn.getAttribute('data-worker-name') || '';
					await openWorkerGraphs(hash, name);
				});
			});
			const sparkCanvases = scope.querySelectorAll('canvas[data-worker-inline-chart][data-worker-hash]');
			sparkCanvases.forEach((canvas) => {
				if (canvas.__workerGraphsAttached) return;
				canvas.__workerGraphsAttached = true;
				canvas.style.cursor = 'pointer';
				const existingTitle = String(canvas.getAttribute('title') || '').trim();
				if (!existingTitle) canvas.setAttribute('title', 'Open worker graphs');
				canvas.addEventListener('click', async () => {
					const hash = String(canvas.getAttribute('data-worker-hash') || '').trim().toLowerCase();
					if (!hash) return;
					let name = '';
					const row = canvas.closest('tr');
					if (row) {
						const btn = row.querySelector('.worker-history-open');
						if (btn) name = String(btn.getAttribute('data-worker-name') || '').trim();
					}
					await openWorkerGraphs(hash, name);
				});
			});
		}

		function renderOnlineWorkers(workers) {
			lastOnlineWorkers = Array.isArray(workers) ? workers.slice() : [];
			if (!onlineWorkersBody) return;
			const nowMillis = Date.now();
			pruneWorkerHashrateFallback(nowMillis);
			pruneWorkerShareRateFallback(nowMillis);
			const data = lastOnlineWorkers.slice();
			data.sort((a, b) => {
				let va;
				let vb;
				if (currentSortField === 'name') {
					va = String(a.name || '').toLowerCase();
					vb = String(b.name || '').toLowerCase();
				} else if (currentSortField === 'hashrate') {
					va = effectiveWorkerHashrate(a, nowMillis);
					vb = effectiveWorkerHashrate(b, nowMillis);
				} else if (currentSortField === 'best_difficulty') {
					va = Number(a.best_difficulty || 0);
					vb = Number(b.best_difficulty || 0);
				} else if (currentSortField === 'difficulty') {
					va = Number(a.difficulty || 0);
					vb = Number(b.difficulty || 0);
				} else if (currentSortField === 'shares_per_minute') {
					va = effectiveWorkerShareRate(a, nowMillis);
					vb = effectiveWorkerShareRate(b, nowMillis);
				} else if (currentSortField === 'accepted') {
					va = Number(a.accepted || 0);
					vb = Number(b.accepted || 0);
				} else if (currentSortField === 'rejected') {
					va = Number(a.rejected || 0);
					vb = Number(b.rejected || 0);
				} else if (currentSortField === 'ping_ms') {
					va = (Number(a.estimated_ping_p50_ms || 0) > 0) ? Number(a.estimated_ping_p50_ms || 0) : Number(a.estimated_ping_p95_ms || 0);
					vb = (Number(b.estimated_ping_p50_ms || 0) > 0) ? Number(b.estimated_ping_p50_ms || 0) : Number(b.estimated_ping_p95_ms || 0);
				} else if (currentSortField === 'connection_duration_seconds') {
					va = Number(a.connection_duration_seconds || 0);
					vb = Number(b.connection_duration_seconds || 0);
				} else if (currentSortField === 'uptime_history') {
					va = Number(computeWorkerHistoryUptimePercent(inlineWorkerChartCache.get(String(a.hash || '').trim().toLowerCase())) || 0);
					vb = Number(computeWorkerHistoryUptimePercent(inlineWorkerChartCache.get(String(b.hash || '').trim().toLowerCase())) || 0);
				} else {
					va = Number(a.connection_seq || 0);
					vb = Number(b.connection_seq || 0);
				}
				if (va < vb) return sortDescending ? 1 : -1;
				if (va > vb) return sortDescending ? -1 : 1;
				return 0;
			});

			if (data.length === 0) {
				if (onlineWorkersCard) onlineWorkersCard.style.display = 'none';
				onlineWorkersBody.innerHTML = '<tr><td class="text-sm">No saved workers online right now.</td></tr>';
				return;
			}
			if (onlineWorkersCard) onlineWorkersCard.style.display = '';
			onlineWorkersBody.innerHTML = data.map((w) => {
				const hashrate = effectiveWorkerHashrate(w, nowMillis);
				const shareRate = effectiveWorkerShareRate(w, nowMillis);
				const hashrateClass = hashrate > 0 ? hashrateClassForAccuracy(w.hashrate_accuracy) : '';
				const hashrateText = hashrate > 0 ? formatWorkerHashrate(hashrate, w.hashrate_accuracy) : 'â€”';
				return `
					<tr class="saved-workers-online-row saved-workers-online-row-main">
						<td class="saved-workers-online-cell">
							<div class="saved-workers-online-block top">
								<div class="saved-workers-online-line">
									<form method="post" action="/worker/remove" data-remove-worker="${escapeAttr(w.name || '')}" class="saved-workers-online-action-remove-mobile">
										<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
										<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
											<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
												<polyline points="3 6 5 6 21 6"></polyline>
												<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
												<path d="M10 11v6"></path>
												<path d="M14 11v6"></path>
												<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
											</svg>
										</button>
									</form>
									<div class="saved-workers-online-name">
										<a class="mono sensitive-worker worker-link" data-worker-name="${escapeAttr(w.name || '')}" data-worker-hash="${escapeAttr(w.hash || '')}" href="/worker/sha256?hash=${escapeAttr(w.hash || '')}">${escapeHTML(normalizeWorkerDisplayName(w.name || w.hash || 'Unknown'))}</a>
									</div>
									<div class="saved-workers-online-stats">
										<span class="saved-workers-online-spark-slot">
											<canvas class="worker-inline-spark worker-inline-spark-combined" width="128" height="16" data-worker-inline-chart="combined" data-worker-hash="${escapeAttr(w.hash || '')}" aria-label="Worker hashrate and best share sparkline"></canvas>
										</span>
										<span class="saved-workers-online-pill">
											<span class="saved-workers-online-pill-label">Hashrate</span>
											<span class="hashrate-value ${hashrateClass} saved-workers-online-pill-value">${hashrateText}</span>
										</span>
										<span class="saved-workers-online-pill">
											<span class="saved-workers-online-pill-label">Best ever</span>
											<span class="saved-workers-online-pill-value">${formatDifficulty(w.best_difficulty)}</span>
										</span>
										<span class="saved-workers-online-pill saved-workers-online-mobile-inline-extra"><span class="saved-workers-online-pill-label">Rejected</span><span class="saved-workers-online-pill-value">${Number(w.rejected || 0).toLocaleString()}</span></span>
										<span class="saved-workers-online-pill saved-workers-online-mobile-inline-extra"><span class="saved-workers-online-pill-label">Connected</span><span class="saved-workers-online-pill-value">${formatDuration(w.connection_duration_seconds)}</span></span>
										<span class="saved-workers-online-pill saved-workers-online-mobile-inline-extra"><span class="saved-workers-online-pill-label">Uptime</span><span class="saved-workers-online-pill-value" data-worker-uptime-history="${escapeAttr(w.hash || '')}">â€”</span></span>
										<span class="saved-workers-online-pill saved-workers-online-pill-mobile-hide"><span class="saved-workers-online-pill-label">Diff</span><span class="saved-workers-online-pill-value">${formatDifficulty(w.difficulty)}</span></span>
										<span class="saved-workers-online-pill saved-workers-online-pill-mobile-hide"><span class="saved-workers-online-pill-label">Shares/min</span><span class="saved-workers-online-pill-value">${formatShareRate(shareRate)}</span></span>
									</div>
								</div>
							</div>
						</td>
					</tr>
					<tr class="saved-workers-online-row saved-workers-online-row-detail">
						<td class="saved-workers-online-cell">
							<div class="saved-workers-online-block bottom">
								<div class="saved-workers-online-line">
									<div class="saved-workers-online-actions">
										<button class="btn btn-secondary worker-graph-btn worker-history-open saved-workers-online-action-graph-mobile-hide" type="button" data-worker-name="${escapeAttr(w.name || '')}" data-worker-hash="${escapeAttr(w.hash || '')}" title="Open worker graphs" aria-label="Open worker graphs">
											<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
												<path d="M3 3v18h18"></path>
												<path d="M7 14l4-4 3 3 5-6"></path>
											</svg>
										</button>
										${discordNotificationsEnabled ? `<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="${escapeAttr(w.hash || '')}" data-notify-enabled="${w.notify_enabled ? '1' : '0'}" title="${escapeAttr(notifyToggleTitle(!!w.notify_enabled))}" aria-label="${escapeAttr(notifyToggleTitle(!!w.notify_enabled))}">${escapeHTML(notifyToggleText(!!w.notify_enabled))}</button>` : ''}
										<form method="post" action="/worker/reconnect" data-reconnect-worker="${escapeAttr(w.name || '')}" class="saved-workers-online-action-reboot">
											<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
											<button class="btn btn-secondary" type="submit" aria-label="Reboot worker" title="Force reset (30s ban + disconnect)">Reboot</button>
										</form>
										<form method="post" action="/worker/remove" data-remove-worker="${escapeAttr(w.name || '')}" class="saved-workers-online-action-remove-bottom-mobile-hide">
											<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
											<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
												<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
													<polyline points="3 6 5 6 21 6"></polyline>
													<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
													<path d="M10 11v6"></path>
													<path d="M14 11v6"></path>
													<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
												</svg>
											</button>
										</form>
									</div>
									<div class="saved-workers-online-stats">
										<span class="saved-workers-online-pill saved-workers-online-pill-mobile-hide"><span class="saved-workers-online-pill-label">Accepted</span><span class="saved-workers-online-pill-value">${Number(w.accepted || 0).toLocaleString()}</span></span>
										<span class="saved-workers-online-pill"><span class="saved-workers-online-pill-label">Rejected</span><span class="saved-workers-online-pill-value">${Number(w.rejected || 0).toLocaleString()}</span></span>
										<span class="saved-workers-online-pill"><span class="saved-workers-online-pill-label">Connected</span><span class="saved-workers-online-pill-value">${formatDuration(w.connection_duration_seconds)}</span></span>
										<span class="saved-workers-online-pill"><span class="saved-workers-online-pill-label">Uptime</span><span class="saved-workers-online-pill-value" data-worker-uptime-history="${escapeAttr(w.hash || '')}">â€”</span></span>
									</div>
								</div>
							</div>
						</td>
					</tr>
			`;
			}).join('');
			attachRemoveConfirms(onlineWorkersBody);
			attachReconnectConfirms(onlineWorkersBody);
			attachNotifyToggles(onlineWorkersBody);
			attachWorkerGraphButtons(onlineWorkersBody);
			refreshInlineWorkerSparklines(onlineWorkersBody);
			drawSavedWorkersTopChart();
		}

		async function copyTextToClipboard(text) {
			const clip = navigator.clipboard;
			if (clip && clip.writeText) {
				await clip.writeText(text);
				return true;
			}
			const ta = document.createElement('textarea');
			ta.value = text;
			ta.setAttribute('readonly', '');
			ta.style.position = 'fixed';
			ta.style.top = '-9999px';
			ta.style.left = '-9999px';
			document.body.appendChild(ta);
			ta.select();
			try {
				return document.execCommand('copy');
			} finally {
				document.body.removeChild(ta);
			}
		}

		async function clearOneTimeCodeServerSide() {
			const code = activeOneTimeCode;
			if (!code) return;
			try {
				await fetchWithAuthRefresh('/api/saved-workers/one-time-code/clear', {
					method: 'POST',
					credentials: 'same-origin',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ code }),
				});
			} catch (_) {
				// ignore
			}
		}

		function clearOneTimeCodeUI(statusText) {
			activeOneTimeCode = '';
			activeExpiresAtMillis = 0;
			if (oneTimeCodeTimeout) {
				clearTimeout(oneTimeCodeTimeout);
				oneTimeCodeTimeout = null;
			}
			if (oneTimeCodeCountdownTimer) {
				clearInterval(oneTimeCodeCountdownTimer);
				oneTimeCodeCountdownTimer = null;
			}
			if (discordCodeEl) discordCodeEl.style.display = 'none';
			if (discordCopyBtn) discordCopyBtn.style.display = 'none';
			if (statusText === 'Expired') {
				setBadge(discordStatusEl, 'Code expired, generate a new one.', true);
				setBadge(discordExpiresEl, 'Expired', true);
			} else {
				setBadge(discordStatusEl, statusText || '', false);
				setBadge(discordExpiresEl, '', false);
			}
		}

		function updateExpiresCountdown() {
			if (!activeOneTimeCode || !activeExpiresAtMillis) {
				setBadge(discordExpiresEl, '', false);
				return;
			}
			const seconds = Math.max(0, Math.ceil((activeExpiresAtMillis - Date.now()) / 1000));
			setBadge(discordExpiresEl, `Expires in ${seconds}s`, false);
			if (seconds <= 0) {
				clearOneTimeCodeUI('Expired');
			}
		}

		function setOneTimeCode(code, expiresAtMillis) {
			activeOneTimeCode = code || '';
			activeExpiresAtMillis = Number(expiresAtMillis) || 0;
			if (discordCodeEl) {
				discordCodeEl.textContent = activeOneTimeCode;
				discordCodeEl.style.display = activeOneTimeCode ? '' : 'none';
			}
			if (discordCopyBtn) discordCopyBtn.style.display = activeOneTimeCode ? '' : 'none';
			setBadge(discordStatusEl, activeOneTimeCode ? 'Copy the code, then run /notify in Discord.' : '', false);
			updateExpiresCountdown();
			if (oneTimeCodeTimeout) clearTimeout(oneTimeCodeTimeout);
			if (oneTimeCodeCountdownTimer) {
				clearInterval(oneTimeCodeCountdownTimer);
				oneTimeCodeCountdownTimer = null;
			}
			if (activeOneTimeCode && expiresAtMillis) {
				const remaining = Math.max(0, expiresAtMillis - Date.now());
				oneTimeCodeTimeout = setTimeout(() => clearOneTimeCodeUI('Expired'), remaining);
				oneTimeCodeCountdownTimer = setInterval(updateExpiresCountdown, 250);
			}
		}

		async function generateOneTimeCode() {
			setBadge(discordStatusEl, 'Generating...', false);
			setBadge(discordExpiresEl, '', false);
			try {
				if (discordRegenBtn) discordRegenBtn.disabled = true;
				if (oneTimeCodeGenerateBtn) oneTimeCodeGenerateBtn.disabled = true;
				const res = await fetchWithAuthRefresh('/api/saved-workers/one-time-code', {
					method: 'POST',
					credentials: 'same-origin',
					headers: { 'Content-Type': 'application/json' },
					body: '{}',
				});
				if (!res.ok) throw new Error('request failed');
				const data = await res.json();
				const code = String(data.code || '');
				const expiresAt = Date.parse(String(data.expires_at || ''));
				if (!code || !isFinite(expiresAt)) throw new Error('bad response');
				setOneTimeCode(code, expiresAt);
			} catch (_) {
				clearOneTimeCodeUI('Error');
			} finally {
				if (discordRegenBtn) discordRegenBtn.disabled = false;
				if (oneTimeCodeGenerateBtn) oneTimeCodeGenerateBtn.disabled = false;
			}
		}

		function openDiscordDialog() {
			if (!discordDialog) return;
			clearOneTimeCodeUI('');
			try {
				if (typeof discordDialog.showModal === 'function') {
					discordDialog.showModal();
				} else {
					discordDialog.setAttribute('open', '');
				}
			} catch (_) {
				discordDialog.setAttribute('open', '');
			}
		}

		function closeDiscordDialog() {
			if (!discordDialog) return;
			try {
				discordDialog.close();
			} catch (_) {
				discordDialog.removeAttribute('open');
			}
		}

		function attachDiscordDialogHandlers() {
			if (oneTimeCodeGenerateBtn && !oneTimeCodeGenerateBtn.__discordDialogAttached) {
				oneTimeCodeGenerateBtn.__discordDialogAttached = true;
				oneTimeCodeGenerateBtn.addEventListener('click', async function() {
					openDiscordDialog();
					await generateOneTimeCode();
				});
			}

			if (discordRegenBtn && !discordRegenBtn.__discordDialogAttached) {
				discordRegenBtn.__discordDialogAttached = true;
				discordRegenBtn.addEventListener('click', async function() {
					await generateOneTimeCode();
				});
			}

			if (discordInviteBtn && !discordInviteBtn.__discordDialogAttached) {
				discordInviteBtn.__discordDialogAttached = true;
				const url = String(discordInviteBtn.getAttribute('data-discord-url') || '').trim();
				if (!url) {
					discordInviteBtn.disabled = true;
					discordInviteBtn.title = 'Discord invite link is not configured for this pool.';
				}
				discordInviteBtn.addEventListener('click', function() {
					const u = String(discordInviteBtn.getAttribute('data-discord-url') || '').trim();
					if (!u) {
						if (discordStatusEl) {
							discordStatusEl.textContent = 'Discord invite link is not configured for this pool.';
							discordStatusEl.style.display = '';
						}
						return;
					}
					window.open(u, '_blank', 'noopener,noreferrer');
				});
			}

			async function doCopy() {
				const code = activeOneTimeCode;
				if (!code) return;
				try {
					const ok = await copyTextToClipboard(code);
					if (!ok) throw new Error('copy failed');
					if (discordStatusEl) {
						discordStatusEl.textContent = 'Copied';
						discordStatusEl.style.display = '';
						setTimeout(() => {
							if (activeOneTimeCode) {
								discordStatusEl.textContent = 'Copy the code, then run /notify in Discord.';
							}
						}, 1200);
					}
				} catch (_) {
					prompt('Copy one-time code:', code);
				}
			}

			if (discordCopyBtn && !discordCopyBtn.__discordDialogAttached) {
				discordCopyBtn.__discordDialogAttached = true;
				discordCopyBtn.addEventListener('click', doCopy);
			}
			if (discordCodeEl && !discordCodeEl.__discordDialogAttached) {
				discordCodeEl.__discordDialogAttached = true;
				discordCodeEl.addEventListener('click', doCopy);
			}

			if (discordDialogClose && !discordDialogClose.__discordDialogAttached) {
				discordDialogClose.__discordDialogAttached = true;
				discordDialogClose.addEventListener('click', async function() {
					await clearOneTimeCodeServerSide();
					clearOneTimeCodeUI('');
					closeDiscordDialog();
				});
			}

			if (discordDialog && !discordDialog.__discordDialogAttached) {
				discordDialog.__discordDialogAttached = true;

				// Click outside closes (native dialogs only).
				discordDialog.addEventListener('click', function(e) {
					if (e.target === discordDialog) {
						discordDialogClose && discordDialogClose.click();
					}
				});

				// Any close (Esc / programmatic) clears the code server-side.
				discordDialog.addEventListener('close', async function() {
					await clearOneTimeCodeServerSide();
					clearOneTimeCodeUI('');
				});
			}
		}

		async function refreshSavedWorkers() {
			try {
				const res = await fetchWithAuthRefresh('/api/saved-workers', { credentials: 'same-origin' });
				if (!res.ok) return;
				const data = await res.json();
				const notifyAllToggle = document.getElementById('notifyAllToggle');
				if (notifyAllToggle && typeof data.discord_registered === 'boolean') {
					const registered = !!data.discord_registered;
					const enabled = !!data.discord_notify_enabled;
					notifyAllToggle.disabled = !registered;
					notifyAllToggle.setAttribute('data-enabled', enabled ? '1' : '0');
					notifyAllToggle.textContent = notifyAllToggleText(enabled);
					notifyAllToggle.title = registered ? notifyAllToggleTitle(enabled) : 'Register first to manage notifications';
				}
				const savedCount = document.getElementById('savedCount');
				const savedMax = document.getElementById('savedMax');
				const onlineCount = document.getElementById('onlineCount');
				if (savedCount) savedCount.textContent = data.saved_count ?? '';
				if (savedMax) savedMax.textContent = data.saved_max ?? '';
				if (onlineCount) onlineCount.textContent = data.online_count ?? '';
				const bestDiffEl = document.getElementById('savedBestDiffValue');
				if (bestDiffEl) {
					bestDiffEl.textContent = formatDifficulty(data.best_difficulty);
				}

				const online = Array.isArray(data.online_workers) ? data.online_workers : [];
				// Update total hashrate time series (sum of online worker hashrate).
				let totalHashrate = 0;
				for (const w of online) {
					totalHashrate += Number(w.hashrate || 0);
				}
				const safeHashrate = isFinite(totalHashrate) ? totalHashrate : 0;
				window.savedWorkersTotalHashrate = safeHashrate;
				updateSavedWorkersTopChartLiveHashrate(safeHashrate);
				renderOnlineWorkers(online);

				const offlineList = document.getElementById('offlineWorkersList');
				const offlineSection = document.getElementById('offlineSection');
				const offlineEmptyMessage = document.getElementById('offlineEmptyMessage');
				const offlineCountBadge = document.getElementById('offlineCountBadge');
				if (offlineList && offlineSection && offlineEmptyMessage) {
					const offline = Array.isArray(data.offline_workers) ? data.offline_workers : [];
					if (offline.length === 0) {
						offlineList.innerHTML = '';
						offlineList.style.display = 'none';
						offlineEmptyMessage.style.display = 'none';
						offlineSection.style.display = 'none';
						if (offlineCountBadge) {
							offlineCountBadge.style.display = 'none';
						}
					} else {
						offlineSection.style.display = '';
						offlineEmptyMessage.style.display = 'none';
						offlineList.style.display = '';
						if (offlineCountBadge) {
							offlineCountBadge.style.display = '';
							offlineCountBadge.textContent = `${offline.length} offline`;
						}
						offlineList.innerHTML = offline.map(w => `
								<li>
									<div class="offline-worker-meta">
										<a class="mono sensitive-worker worker-link" data-worker-name="${escapeAttr(w.name || '')}" data-worker-hash="${escapeAttr(w.hash || '')}" href="/worker/sha256?hash=${escapeAttr(w.hash || '')}">${escapeHTML(normalizeWorkerDisplayName(w.name || w.hash || 'Unknown'))}</a>
										<span class="text-sm offline-last-online" data-last-online-at="${escapeAttr(w.last_online_at || '')}"></span>
										<span class="text-sm" style="color:var(--text-muted);">Best share: ${formatDifficulty(w.best_difficulty)}</span>
									</div>
								<span class="badge badge-danger">Offline</span>
								<div class="offline-actions" style="display:flex; gap:8px; justify-content:flex-end; align-items:center;">
									${discordNotificationsEnabled ? `<button class="btn btn-secondary worker-notify-toggle" type="button" data-worker-hash="${escapeAttr(w.hash || '')}" data-notify-enabled="${w.notify_enabled ? '1' : '0'}" title="${escapeAttr(notifyToggleTitle(!!w.notify_enabled))}">${escapeHTML(notifyToggleText(!!w.notify_enabled))}</button>` : ''}
									<form method="post" action="/worker/remove" style="margin:0;" data-remove-worker="${escapeAttr(w.name || '')}">
										<input type="hidden" name="hash" value="${escapeAttr(w.hash || '')}">
										<button class="btn btn-secondary" type="submit" aria-label="Remove worker" title="Remove">
											<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
												<polyline points="3 6 5 6 21 6"></polyline>
												<path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
												<path d="M10 11v6"></path>
												<path d="M14 11v6"></path>
												<path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"></path>
											</svg>
										</button>
									</form>
								</div>
							</li>
						`).join('');
						applyLastOnlineLabels(offlineList);
						attachRemoveConfirms(offlineList);
						attachNotifyToggles(offlineList);
					}
				}
			} catch (_) {}
		}

		function escapeHTML(str) {
			return String(str)
				.replaceAll('&', '&amp;')
				.replaceAll('<', '&lt;')
				.replaceAll('>', '&gt;')
				.replaceAll('"', '&quot;')
				.replaceAll("'", '&#39;');
		}

		function escapeAttr(str) {
			return escapeHTML(str);
		}

		attachRemoveConfirms(document);
		attachReconnectConfirms(document);
		applyLastOnlineLabels(document);
		attachNotifyToggles(document);
		attachWorkerGraphButtons(document);
		attachNotifyAllButtons();
		attachDiscordDialogHandlers();
		attachWalletLookupAddHandlers();
		refreshInlineWorkerSparklines(document);
		updateWalletLookupAddAllState();

		// Best-effort: keep the login cookie fresh while this page is open.
		if (clerkEnabled) {
			setInterval(() => { refreshClerkSession(); }, 60 * 1000);
		}

		if (workerGraphsClose && !workerGraphsClose.__workerGraphsCloseAttached) {
			workerGraphsClose.__workerGraphsCloseAttached = true;
			workerGraphsClose.addEventListener('click', () => {
				try {
					workerGraphsDialog?.close();
				} catch (_) {
					workerGraphsDialog?.removeAttribute('open');
				}
			});
		}
		if (workerGraphsDialog && !workerGraphsDialog.__workerGraphsDialogAttached) {
			workerGraphsDialog.__workerGraphsDialogAttached = true;
			workerGraphsDialog.addEventListener('click', (e) => {
				if (e.target === workerGraphsDialog) {
					try {
						workerGraphsDialog.close();
					} catch (_) {
						workerGraphsDialog.removeAttribute('open');
					}
				}
			});
		}

		refreshSavedWorkers();
		setInterval(refreshSavedWorkers, 5000);
		setInterval(() => refreshInlineWorkerSparklines(document), inlineWorkerChartRefreshMS);
		window.addEventListener('resize', drawSavedWorkersTopChart);
		window.addEventListener('resize', () => {
			const hash = String(workerGraphsSubtitle?.getAttribute('data-worker-hash') || '').trim().toLowerCase();
			if (!hash) return;
			const cached = inlineWorkerChartCache.get(hash);
			if (!cached) return;
			drawWorkerCombinedHistoryGraph(workerGraphsCombinedCanvas, cached.hashrateRows, cached.bestRows);
		});
		updateSortOrderButtonText();
		if (sortFieldSelect) {
			sortFieldSelect.value = currentSortField;
		}
		if (sortFieldSelect) {
			sortFieldSelect.addEventListener('change', function() {
				currentSortField = sortFieldSelect.value || 'connection_seq';
				renderOnlineWorkers(lastOnlineWorkers);
			});
		}
		if (sortOrderBtn) {
			sortOrderBtn.addEventListener('click', function() {
				sortDescending = !sortDescending;
				updateSortOrderButtonText();
				renderOnlineWorkers(lastOnlineWorkers);
			});
		}
	})();
	</script>
	<script>
		(function() {
			const REFRESH_INTERVAL = 5000;
			const FIAT_CURRENCY = '{{.FiatCurrency}}';
			const OVERVIEW_CACHE_KEY = 'savedWorkers.overview.v1';
			const HASHRATE_CACHE_KEY = 'savedWorkers.hashrate.v1';
			const poolTagEl = document.getElementById('status-pool-tag');
		const valueEl = document.getElementById('status-pool-hashrate');
		const blockHeightEl = document.getElementById('status-block-height');
		const blockHeightContextEl = document.getElementById('status-block-height-context');
		const blockDifficultyEl = document.getElementById('status-block-difficulty');
		const networkHashrateEl = document.getElementById('status-network-hashrate');
		const blockChanceEl = document.getElementById('status-block-chance');
		const templateTxFeesEl = document.getElementById('status-template-tx-fees');
		const templateTxFeesUpdatedEl = document.getElementById('status-template-tx-fees-updated');
		const blockTimeLeftEl = document.getElementById('status-block-time-left');
		const blockHistoryEl = document.getElementById('status-block-history');

		let btcPriceFiat = 0;
		let fiatCurrency = 'USD';
		let blockTimeLeftSec = null;
		let blockTimeOverdueSec = 0;
		let isBlockTimeOverdue = false;
			let templateUpdatedAtMillis = null;
			let templateTxFeesSats = null;

			function readRecentJSONCache(key, maxAgeMs) {
				try {
					const raw = sessionStorage.getItem(key);
					if (!raw) return null;
					const parsed = JSON.parse(raw);
					if (!parsed || typeof parsed !== 'object') return null;
					const at = Number(parsed.at || 0);
					if (!Number.isFinite(at) || at <= 0) return null;
					if ((Date.now() - at) > maxAgeMs) return null;
					return parsed.payload ?? null;
				} catch (_) {
					return null;
				}
			}

			function writeJSONCache(key, payload) {
				try {
					sessionStorage.setItem(key, JSON.stringify({
						at: Date.now(),
						payload: payload,
					}));
				} catch (_) {}
			}

		// Used by the saved workers table (hashrate cells render from data-hashrate attributes).
		// This script block runs separately from the main saved-workers dashboard script above,
		// so it must define its own helper to avoid ReferenceError and breaking status boxes.
			function renderStoredHashrates() {
				const cells = document.querySelectorAll('[data-hashrate]');
				cells.forEach((el) => {
					const value = Number(el.getAttribute('data-hashrate'));
					const accuracy = el.getAttribute('data-hashrate-accuracy');
					el.classList.remove('hashrate-warming', 'hashrate-settling', 'hashrate-solid');
					if (!value) {
						el.textContent = 'â€”';
						return;
					}
					const cls = hashrateClassForAccuracy(accuracy);
					if (cls) el.classList.add(cls);
					el.textContent = formatWorkerHashrate(value, accuracy);
				});
			}

		function normalizeFiatCurrency(cur) {
			const s = String(cur ?? '').trim();
			return s ? s.toUpperCase() : 'USD';
		}

		function formatFiatNoDecimals(value, currency) {
			const amount = Number(value);
			if (!Number.isFinite(amount)) {
				return null;
			}
			try {
				return new Intl.NumberFormat('en-US', { style: 'currency', currency, maximumFractionDigits: 0 }).format(amount);
			} catch (_) {
				return amount.toFixed(0);
			}
		}

			function formatHashrate(value) {
			if (!value || value <= 0) {
				return '---';
			}
			const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
			let val = value;
			let idx = 0;
			while (val >= 1000 && idx < units.length - 1) {
				val /= 1000;
				idx++;
			}
				return `${val.toFixed(2)} ${units[idx]}`;
			}

			function formatWorkerHashrate(value, accuracy) {
				const base = formatHashrate(value);
				if (base === 'â€”' || base === '---') return 'â€”';
				let marker = String(accuracy || '').trim();
				if (marker === 'â‰ˆ+' || marker === 'âœ“') marker = '';
				return marker ? `${marker} ${base}` : base;
			}

				function hashrateClassForAccuracy(accuracy) {
					const marker = String(accuracy || '').trim();
					if (marker === '~') return 'hashrate-warming';
					if (marker === 'â‰ˆ') return 'hashrate-settling';
					if (marker === 'â‰ˆ+' || marker === 'âœ“' || marker === '') return 'hashrate-solid';
					return '';
				}

		function formatShareRate(rate) {
			if (!rate) return '0';
			if (rate < 1000) return rate.toFixed(1);
			if (rate < 1000000) return (rate / 1000).toFixed(1) + 'K';
			if (rate < 1000000000) return (rate / 1000000).toFixed(1) + 'M';
			return (rate / 1000000000).toFixed(1) + 'G';
		}

		function normalizePoolTag(tag) {
			if (!tag) return '';
			if (tag[0] === '/') return tag;
			return '/' + tag;
		}

		function updateGridCards(newData) {
			if (!newData) return;
			const poolGroupTitle = document.querySelector('.status-group .status-group-title');
			if (poolGroupTitle && poolGroupTitle.textContent.trim().toLowerCase() === 'pool') {
				poolGroupTitle.textContent = 'Your stats';
			}
			const cardContainers = document.querySelectorAll('.grid > .card');
			cardContainers.forEach(card => {
				const label = card.querySelector('.label');
				const valueEl = card.querySelector('.value');
				if (!label || !valueEl) return;
				const rawLabelText = label.textContent.trim();
				if (rawLabelText === 'Estimated pool hashrate' || rawLabelText === 'Pool hashrate') {
					label.textContent = 'Your hashrate';
				}
				const labelText = label.textContent.trim();
				switch (labelText) {
					case 'Open connections':
						{
							const total = newData.active_miners ?? 0;
							const tls = newData.active_tls_miners ?? 0;
							valueEl.innerHTML = `${total} <span class="text-sm" style="color:#666;">(${tls} TLS)</span>`;
						}
						break;
					case 'Shares per minute':
						{
							const rate = newData.shares_per_minute ?? 0;
							const workers = newData.active_miners ?? 0;
							const avgPerWorker = workers > 0 ? rate / workers : 0;
							if (workers > 0) {
								valueEl.innerHTML = `${formatShareRate(rate)} <span class="text-sm" style="color:#666;">(${formatShareRate(avgPerWorker)}/worker)</span>`;
							} else {
								valueEl.textContent = formatShareRate(rate);
							}
							const contextEl = card.querySelector('.card-context');
							if (contextEl) {
								if (workers > 0) {
									contextEl.textContent = `${formatShareRate(avgPerWorker)} avg/worker`;
								} else {
									contextEl.textContent = 'Indicative of server load';
								}
							}
						}
						break;
					case 'Estimated pool hashrate':
					case 'Pool hashrate':
					case 'Your hashrate':
						{
							const rate = typeof window.savedWorkersTotalHashrate === 'number'
								? window.savedWorkersTotalHashrate
								: newData.pool_hashrate;
							valueEl.textContent = formatHashrate(rate);
						}
						break;
				}
			});
		}

		function updateBTCPrice(newData) {
			if (!newData) return;
			const priceEl = document.getElementById('status-btc-price');
			const updatedEl = document.getElementById('status-btc-price-updated');
			fiatCurrency = normalizeFiatCurrency(newData.fiat_currency || FIAT_CURRENCY);
			const price = Number(newData.btc_price_fiat ?? 0);
			btcPriceFiat = price;
			if (priceEl) {
				const formatted = price > 0 ? formatFiatNoDecimals(Math.round(price), fiatCurrency) : null;
				priceEl.textContent = formatted ? ('BTC ' + formatted + ' ' + fiatCurrency) : '--';
			}
			if (updatedEl) {
				const ts = newData.btc_price_updated_at;
				if (ts) {
					try {
						const d = new Date(ts);
						updatedEl.textContent = 'Updated ' + d.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
					} catch (_) {
						updatedEl.textContent = 'Updated --';
					}
				} else {
					updatedEl.textContent = 'Updated --';
				}
			}
		}

		function updateOverviewDOM(newData) {
			if (!newData) return;
			if (poolTagEl) {
				const tag = normalizePoolTag(newData.pool_tag);
				poolTagEl.textContent = tag || '--';
			}
			updateGridCards(newData);
			updateBTCPrice(newData);
		}

		function formatOddsText(chance) {
			if (!chance || chance <= 0) {
				return '1 in âˆž';
			}
			const ratio = 1 / chance;
			if (!Number.isFinite(ratio)) {
				return '1 in âˆž';
			}

			const largeUnits = [
				{ value: 1e12, label: 'trillion' },
				{ value: 1e9, label: 'billion' },
				{ value: 1e6, label: 'million' },
			];

			for (const { value, label } of largeUnits) {
				if (ratio >= value) {
					const scaled = ratio / value;
					const precision = scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2;
					const formatted = scaled.toFixed(precision).replace(/\.?0+$/, '');
					return `1 in ${formatted} ${label}`;
				}
			}

			const rounded = Math.max(1, Math.round(ratio));
			return `1 in ${rounded.toLocaleString()}`;
		}

		function formatDifficulty(diff) {
			if (!diff || diff <= 0) {
				return '--';
			}
			if (diff < 1000000) return diff.toFixed(0);
			if (diff >= 1000000000000000) {
				return (diff / 1000000000000000).toFixed(1) + 'P';
			}
			if (diff >= 1000000000000) {
				return (diff / 1000000000000).toFixed(1) + 'T';
			}
			if (diff >= 1000000000) {
				return (diff / 1000000000).toFixed(1) + 'G';
			}
			return (diff / 1000000).toFixed(1) + 'M';
		}

		function formatDuration(seconds) {
			const total = Math.max(0, Math.floor(seconds ?? 0));
			const hours = Math.floor(total / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;
			if (hours > 0) {
				return `${hours}h ${minutes}m`;
			}
			if (minutes > 0) {
				return `${minutes}m ${secs}s`;
			}
			return `${secs}s`;
		}

		function formatBTCShort(sats) {
			const btc = (Number(sats) || 0) / 1e8;
			return `${btc.toFixed(8)} BTC`;
		}

		function formatFiat(amount, currency) {
			const value = Number(amount);
			if (!Number.isFinite(value)) {
				return null;
			}
			try {
				return new Intl.NumberFormat('en-US', { style: 'currency', currency, maximumFractionDigits: 2 }).format(value);
			} catch (_) {
				return '$' + value.toFixed(2);
			}
		}

		function formatHHMMSSUTC(millis) {
			if (typeof millis !== 'number' || !Number.isFinite(millis)) {
				return null;
			}
			const date = new Date(millis);
			if (Number.isNaN(date.getTime())) {
				return null;
			}
			return date.toISOString().substring(11, 19) + ' UTC';
		}

		function formatTimeAgoMillis(millis) {
			if (typeof millis !== 'number' || !Number.isFinite(millis)) {
				return null;
			}
			const diffSec = Math.floor((Date.now() - millis) / 1000);
			if (diffSec < 0) return 'just now';
			if (diffSec < 5) return 'just now';
			if (diffSec < 60) return `${diffSec}s ago`;
			if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m ago`;
			if (diffSec < 86400) return `${Math.floor(diffSec / 3600)}h ago`;
			const days = Math.floor(diffSec / 86400);
			if (days < 7) return `${days}d ago`;
			if (days < 30) return `${Math.floor(days / 7)}w ago`;
			if (days < 365) return `${Math.floor(days / 30)}mo ago`;
			return `${Math.floor(days / 365)}y ago`;
		}

		function renderTemplateTxFees() {
			if (!templateTxFeesEl) {
				return;
			}
			if (typeof templateTxFeesSats !== 'number' || templateTxFeesSats < 0) {
				templateTxFeesEl.textContent = '--';
				if (templateTxFeesUpdatedEl) {
					templateTxFeesUpdatedEl.textContent = 'Updated --';
				}
				return;
			}
			const btcText = formatBTCShort(templateTxFeesSats);
			const currency = normalizeFiatCurrency(fiatCurrency || FIAT_CURRENCY);
			const fiatText = btcPriceFiat > 0 ? formatFiat((Number(templateTxFeesSats) / 1e8) * btcPriceFiat, currency) : null;
			templateTxFeesEl.innerHTML = fiatText
				? `${btcText}<br><span style="opacity:0.7; font-size:0.85em;">(${fiatText} ${currency})</span>`
				: btcText;
			if (templateTxFeesUpdatedEl) {
				const when = formatHHMMSSUTC(templateUpdatedAtMillis);
				const ago = formatTimeAgoMillis(templateUpdatedAtMillis);
				const parts = [];
				if (when) parts.push(when);
				if (ago) parts.push(`(${ago})`);
				templateTxFeesUpdatedEl.textContent = parts.length ? `Updated ${parts.join(' ')}` : 'Updated --';
			}
		}

		function formatDurationDetailed(seconds) {
			const total = Math.max(0, Math.floor(seconds ?? 0));
			const days = Math.floor(total / 86400);
			const hours = Math.floor((total % 86400) / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;

			const parts = [];
			if (days > 0) parts.push(`${days}d`);
			if (hours > 0) parts.push(`${hours}h`);
			if (minutes > 0) parts.push(`${minutes}m`);
			if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

			return parts.slice(0, 3).join(' ');
		}

		function getUpdatedAtMillis(value) {
			if (!value) {
				return null;
			}
			const parsed = Date.parse(value);
			if (Number.isNaN(parsed)) {
				return null;
			}
			return parsed;
		}

		function renderBlockTimeLeft() {
			if (!blockTimeLeftEl) {
				return;
			}
			if (isBlockTimeOverdue) {
				blockTimeLeftEl.textContent = `overdue ${formatDuration(blockTimeOverdueSec)}`;
				return;
			}
			if (typeof blockTimeLeftSec !== 'number') {
				blockTimeLeftEl.textContent = '--';
				return;
			}
			blockTimeLeftEl.textContent = formatDuration(blockTimeLeftSec);
		}

		function renderBlockHistory(recentBlockTimes) {
			if (!blockHistoryEl) {
				return;
			}
			if (!recentBlockTimes || recentBlockTimes.length === 0) {
				blockHistoryEl.innerHTML = '--';
				return;
			}

			const durations = [];
			for (let i = recentBlockTimes.length - 1; i >= 1; i--) {
				const prev = new Date(recentBlockTimes[i - 1]).getTime();
				const curr = new Date(recentBlockTimes[i]).getTime();
				const durationSec = Math.floor((curr - prev) / 1000);
				if (durationSec <= 0) {
					durations.push('timestamp skew');
				} else {
					durations.push(formatDurationDetailed(durationSec));
				}
				if (durations.length >= 3) break;
			}

			if (durations.length === 0) {
				blockHistoryEl.innerHTML = '--';
			} else {
				// Render left-to-right to save vertical space.
				blockHistoryEl.textContent = durations.join(' | ');
			}
		}

		function updateHashrateDisplay(rate) {
			if (!valueEl) return;
			if (typeof window.savedWorkersTotalHashrate === 'number') {
				valueEl.textContent = formatHashrate(window.savedWorkersTotalHashrate);
				return;
			}
			const formatted = formatHashrate(rate);
			if (valueEl.textContent !== formatted) {
				valueEl.textContent = formatted;
			}
		}

		function fetchOverview() {
			fetch('/api/overview', { credentials: 'same-origin' })
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					return response.json();
				})
				.then(data => {
					writeJSONCache(OVERVIEW_CACHE_KEY, data);
					updateOverviewDOM(data);
				})
				.catch(err => {
					console.error('Error fetching overview stats:', err);
				});
		}

		function fetchHashrate() {
			fetch('/api/pool-hashrate', { credentials: 'same-origin' })
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					const updatedAt = response.headers.get('X-JSON-Updated-At');
					return response.json().then(data => ({ data, updatedAt }));
				})
				.then(({ data, updatedAt }) => {
					writeJSONCache(HASHRATE_CACHE_KEY, { data, updatedAt });
					if (data && typeof data.pool_hashrate === 'number') {
						updateHashrateDisplay(data.pool_hashrate);
					}
					if (data && typeof data.template_tx_fees_sats === 'number') {
						templateTxFeesSats = data.template_tx_fees_sats;
					} else {
						templateTxFeesSats = null;
					}
					templateUpdatedAtMillis = getUpdatedAtMillis(data?.template_updated_at) ?? getUpdatedAtMillis(updatedAt || data?.updated_at);
					renderTemplateTxFees();
					if (blockHeightEl && typeof data.block_height === 'number' && data.block_height > 0) {
						const height = data.block_height;
						blockHeightEl.textContent = height.toLocaleString();
						if (blockHeightContextEl) {
							const retarget = data.next_difficulty_retarget;
							if (retarget && typeof retarget.height === 'number' && retarget.height > 0) {
								const parts = [];
								if (typeof retarget.blocks_away === 'number') {
									parts.push(null);
								}
								if (retarget.duration_estimate) {
									parts.push(`~${retarget.duration_estimate}`);
								}
								if (parts.length === 0) {
									parts.push('~--');
								}
								const summary = parts.filter(Boolean).join(' Â· ');
								blockHeightContextEl.innerHTML = `${retarget.height.toLocaleString()}<br><span class="text-sm" style="color:var(--text-muted);">(${summary})</span>`;
							} else {
								const interval = 2016;
								const next = (Math.floor(height / interval) + 1) * interval;
								const remaining = Math.max(0, next - height);
								const durationSeconds = remaining * 10 * 60;
								const durationText = formatDuration(durationSeconds);
								blockHeightContextEl.innerHTML = `${next.toLocaleString()}<br><span class="text-sm" style="color:var(--text-muted);">(~${durationText})</span>`;
							}
						}
					} else if (blockHeightEl) {
						blockHeightEl.textContent = '--';
						if (blockHeightContextEl) {
							blockHeightContextEl.textContent = '--';
						}
					}
					let networkHashrate = null;
					if (blockDifficultyEl && typeof data.block_difficulty === 'number') {
						blockDifficultyEl.textContent = formatDifficulty(data.block_difficulty);
						networkHashrate = data.block_difficulty * 4294967296 / (10 * 60);
					}
					if (networkHashrateEl) {
						const networkHashrateText = networkHashrate ? formatHashrate(networkHashrate) : '--';
						networkHashrateEl.textContent = networkHashrateText;
					}
					if (blockChanceEl) {
						let chanceText = '--';
						if (networkHashrate && typeof data.pool_hashrate === 'number' && data.pool_hashrate > 0) {
							const share = Math.min(1, data.pool_hashrate / networkHashrate);
							const chance = 1 - Math.pow(1 - share, 52560);
							chanceText = formatOddsText(chance);
						}
						blockChanceEl.textContent = chanceText;
					}
					if (blockTimeLeftEl) {
						let secondsLeft = null;

						if (typeof data.block_time_left_sec === 'number' && data.block_time_left_sec >= 0) {
							secondsLeft = data.block_time_left_sec;
							const updatedMillis = getUpdatedAtMillis(updatedAt || data.updated_at);
							if (updatedMillis !== null) {
								const ageSec = Math.max(0, (Date.now() - updatedMillis) / 1000);
								secondsLeft = secondsLeft - ageSec;
							}
						} else if (data.recent_block_times && data.recent_block_times.length > 0) {
							const mostRecentBlockTime = new Date(data.recent_block_times[data.recent_block_times.length - 1]).getTime();
							const targetInterval = 10 * 60 * 1000;
							const expectedEndTime = mostRecentBlockTime + targetInterval;
							secondsLeft = Math.floor((expectedEndTime - Date.now()) / 1000);
						}

						if (secondsLeft === null) {
							blockTimeLeftSec = null;
							isBlockTimeOverdue = false;
							blockTimeOverdueSec = 0;
						} else if (secondsLeft <= 0) {
							blockTimeLeftSec = 0;
							isBlockTimeOverdue = true;
							blockTimeOverdueSec = Math.floor(Math.max(0, -secondsLeft));
						} else {
							blockTimeLeftSec = secondsLeft;
							isBlockTimeOverdue = false;
							blockTimeOverdueSec = 0;
						}
						renderBlockTimeLeft();
					}
					if (data.recent_block_times) {
						renderBlockHistory(data.recent_block_times);
					}
				})
				.catch(err => {
					console.error('Error fetching pool hashrate:', err);
				});
		}

			fiatCurrency = normalizeFiatCurrency(FIAT_CURRENCY);
			const cachedOverview = readRecentJSONCache(OVERVIEW_CACHE_KEY, REFRESH_INTERVAL);
			if (cachedOverview) {
				updateOverviewDOM(cachedOverview);
			}
			const cachedHashrate = readRecentJSONCache(HASHRATE_CACHE_KEY, REFRESH_INTERVAL);
			if (cachedHashrate && cachedHashrate.data) {
				const data = cachedHashrate.data;
				const updatedAt = cachedHashrate.updatedAt;
				if (typeof data.pool_hashrate === 'number') {
					updateHashrateDisplay(data.pool_hashrate);
				}
				if (typeof data.template_tx_fees_sats === 'number') {
					templateTxFeesSats = data.template_tx_fees_sats;
				} else {
					templateTxFeesSats = null;
				}
				templateUpdatedAtMillis = getUpdatedAtMillis(data?.template_updated_at) ?? getUpdatedAtMillis(updatedAt || data?.updated_at);
				renderTemplateTxFees();
				if (blockHeightEl && typeof data.block_height === 'number' && data.block_height > 0) {
					blockHeightEl.textContent = data.block_height.toLocaleString();
				}
				if (blockDifficultyEl && typeof data.block_difficulty === 'number') {
					blockDifficultyEl.textContent = formatDifficulty(data.block_difficulty);
				}
				if (data.recent_block_times) {
					renderBlockHistory(data.recent_block_times);
				}
			}
			fetchOverview();
			renderStoredHashrates();
			fetchHashrate();
		setInterval(fetchOverview, REFRESH_INTERVAL);
		setInterval(fetchHashrate, REFRESH_INTERVAL);
		setInterval(() => {
			renderTemplateTxFees();
			if (typeof blockTimeLeftSec !== 'number') {
				return;
			}
			if (isBlockTimeOverdue) {
				blockTimeOverdueSec += 1;
			} else {
				blockTimeLeftSec -= 1;
				if (blockTimeLeftSec <= 0) {
					blockTimeLeftSec = 0;
					isBlockTimeOverdue = true;
					blockTimeOverdueSec = 0;
				}
			}
			renderBlockTimeLeft();
		}, 1000);
	})();
	</script>
	{{end}}
</body>
</html>
