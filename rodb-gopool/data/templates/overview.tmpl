{{/* Status page template (migrated from status.html) */}}
<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="icon" type="image/png" sizes="64x64" href="/favicon.png">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{{if .BrandDomain}}{{.BrandDomain}}{{else}}{{.BrandName}}{{end}} — Overview</title>
	<link rel="stylesheet" href="/style.css">
	<style>
		.hashrate-warming {
			opacity: 0.72;
		}
		.hashrate-settling {
			opacity: 0.82;
		}
		.hashrate-solid {
			opacity: 1;
		}
	</style>
</head>
<body>
	{{template "header" .}}
	<main class="page" id="content">
		<noscript>
			<div class="card">
				<p class="text-sm" style="color:#f88d8d;margin:0;">
					JavaScript is required to load live stats on this page. For a no-JS view, use <a class="mono" href="/api/overview">/api/overview</a>.
				</p>
			</div>
		</noscript>
			<div class="overview-banner" id="overview-banner" data-host="{{.BrandDomain}}">
				<div class="connect-panel">
					<div class="connect-panel-header">
						<div class="connect-panel-intro">
							<p class="connect-panel-title">
								How to connect your miner!
									<button type="button" class="connect-panel-fold" id="connect-panel-fold-toggle" aria-controls="connect-panel-body" aria-expanded="false">show info</button>
								{{if .ConnectMinerTitleExtra}}{{if .ConnectMinerTitleExtraURL}} -- <a href="{{.ConnectMinerTitleExtraURL}}">{{.ConnectMinerTitleExtra}}</a>{{else}} -- {{.ConnectMinerTitleExtra}}{{end}}{{end}}
							</p>
						</div>
					</div>
					<div class="connect-panel-body" id="connect-panel-body">
					<div class="connect-steps">
					<div class="connect-step">
						<div class="connect-step-head">
							<div class="connect-step-number">1</div>
							<div class="connect-step-label">Pool URL</div>
						</div>
						<div class="connect-step-body">
							<div class="connect-copy-row">
								<button type="button" class="copy-pill stratum-copy" data-copy-scheme="stratum+tcp://" data-copy-port="{{addrPort .ListenAddr}}" aria-label="Copy pool URL">
									<span class="copy-pill-action">Click to copy</span>
									<span class="copy-pill-value">stratum+tcp://<span data-stratum-host></span>:{{addrPort .ListenAddr}}</span>
								</button>
								<span class="copy-feedback" aria-live="polite"></span>
							</div>
							{{if .StratumTLSListen}}
							<details class="connect-advanced">
								<summary>Optional: encrypted connection (TLS)</summary>
								<div class="connect-advanced-body">
									<p class="text-sm connect-hint">Use this only if your miner supports Stratum TLS.</p>
									<div class="connect-copy-row">
										<button type="button" class="copy-pill stratum-copy" data-copy-scheme="stratum+tls://" data-copy-port="{{addrPort .StratumTLSListen}}" aria-label="Copy encrypted pool URL (TLS)">
											<span class="copy-pill-action">Click to copy</span>
											<span class="copy-pill-value">stratum+tls://<span data-stratum-host></span>:{{addrPort .StratumTLSListen}}</span>
										</button>
										<span class="copy-feedback" aria-live="polite"></span>
									</div>
								</div>
							</details>
							{{end}}
						</div>
					</div>

					<div class="connect-step">
						<div class="connect-step-head">
							<div class="connect-step-number">2</div>
							<div class="connect-step-label">Username</div>
						</div>
						<div class="connect-step-body">
							<div class="connect-value mono">YourBTCAddress.WorkerName</div>
							<p class="text-sm connect-hint">Be sure to use a unique name for each worker on the same wallet!</p>
						</div>
					</div>

					{{if .StratumPasswordEnabled}}
						{{if .StratumPasswordPublic}}
						<div class="connect-step">
							<div class="connect-step-head">
								<div class="connect-step-number">3</div>
								<div class="connect-step-label">Password</div>
							</div>
							<div class="connect-step-body">
								<div class="connect-value mono">{{.StratumPassword}}</div>
							</div>
						</div>
						{{end}}
					{{else}}
					<div class="connect-step">
						<div class="connect-step-head">
							<div class="connect-step-number">3</div>
							<div class="connect-step-label">Password</div>
						</div>
						<div class="connect-step-body">
							<div class="connect-value mono">x</div>
							<p class="text-sm connect-hint">Most miners use <span class="mono">x</span> by default, but any password will work.</p>
						</div>
					</div>
					{{end}}
				</div>

					{{if gt .MinDifficulty 0.0}}
					<p class="text-sm connect-note" style="margin-top:2px;">
						Min hashrate: <span class="mono">{{formatHashrate .MinHashrateForTarget}}</span>
						<span style="opacity:0.85;">(diff <span class="mono">{{formatDiff .MinDifficulty}}</span>, ~{{printf "%.0f" .TargetSharesPerMin}} shares/min)</span>
					</p>
					{{end}}
					{{if gt .MaxDifficulty 0.0}}
					<p class="text-sm connect-note" style="margin-top:2px;">
						Max hashrate: <span class="mono">{{formatHashrate .MaxHashrateForTarget}}</span>
						<span style="opacity:0.85;">(diff <span class="mono">{{formatDiff .MaxDifficulty}}</span>, ~{{printf "%.0f" .TargetSharesPerMin}} shares/min)</span>
					</p>
					{{end}}
					{{if .BannedMinerTypes}}
					<p class="text-sm connect-note" style="margin-top:2px;">
						Blocked miner clients: <span class="mono">{{join .BannedMinerTypes ", "}}</span>
					</p>
					{{end}}

					<p class="text-sm connect-note">
						By connecting you confirm that you accept the <a href="/terms">Terms of Use</a> and should review our <a href="/privacy">Privacy Policy</a> (Last Updated: February 14, 2026) before mining.
					</p>
					</div>
				</div>
		</div>
		{{template "status_boxes" .}}

		<div style="margin-top:16px;">
			{{template "hashrate_graph" .}}
		</div>

		<h2 id="workers">Recent work</h2>
		<div class="card">
			<p class="text-sm" style="color:var(--text-muted); margin-top:0;">
				Hashrate markers: <span class="mono">~</span> warming, <span class="mono">≈</span> settling, stable (no symbol).
			</p>
			<div style="overflow-x:auto;">
				<table class="table" id="status-workers-table">
					<thead>
						<tr>
							<th title="Worker name"><span class="th-full">Worker</span><span class="th-short">.worker</span></th>
							<th title="Connection number">Conn</th>
							<th title="Rolling hashrate">Hashrate</th>
							<th title="Current difficulty">Difficulty</th>
							<th title="Accepted shares per minute">Shares/min</th>
							<th title="Total accepted shares">Accepted</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td colspan="6" class="text-sm" id="status-workers-placeholder">Loading worker stats…</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>

		<h2>Best shares</h2>
		<div class="card">
			<div style="overflow-x:auto;">
				<table class="table" id="status-best-shares-table">
					<thead>
						<tr>
							<th><span class="th-full">Worker</span><span class="th-short">.worker</span></th>
							<th>Difficulty</th>
							<th><span class="th-full">When</span><span class="th-short">Age</span></th>
							<th>Hash</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td colspan="4" class="text-sm">Loading best shares…</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>

		<h2>Found blocks</h2>
		<div class="card">
			<div style="overflow-x:auto;">
				<table class="table" id="status-found-blocks-table">
					<thead>
						<tr>
							<th>Height</th>
							<th>Hash</th>
							<th><span class="th-full">Miner</span><span class="th-short">.worker</span></th>
							<th>Result</th>
							<th><span class="th-full">Confirmations</span><span class="th-short">Conf</span></th>
							<th>Pool (sats)</th>
							<th>Worker (sats)</th>
							<th><span class="th-full">Share difficulty</span><span class="th-short">Diff</span></th>
							<th>When</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td colspan="9" class="text-sm">Loading found blocks…</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>

		<h2>Miner types</h2>
		<div class="card" id="status-miner-types-card">
			<p class="text-sm" id="status-miner-types-placeholder">Loading miner type data…</p>
			<ul class="list" id="status-miner-types-list" style="display:none;"></ul>
		</div>

		<h2>Banned workers</h2>
		<div class="card">
			<p class="text-sm" style="margin-top:0;margin-bottom:8px;color:#f88d8d;" id="status-banned-placeholder-text">
				Loading banned worker data…
			</p>
			<div style="overflow-x:auto;">
				<table class="table" id="status-banned-workers-table">
					<thead>
						<tr>
							<th title="Worker name">Worker</th>
							<th title="Ban details">Ban status</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td colspan="2" class="text-sm" id="status-banned-workers-placeholder">Loading banned workers…</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>

		<div style="margin-top:16px;padding:8px;text-align:center;font-size:0.85em;color:#888;">
			<div class="mono" id="overview-data-refreshed">Data loading...</div>
			<div style="margin-top:4px;">
				Rendered in <span class="mono" id="overview-render-time">--</span>
			</div>
		</div>

		{{template "footer" .}}
	</main>
	{{template "hashrate_graph_script" .}}
	<script>
	(function() {
		const REFRESH_INTERVAL = 10000; // 10 seconds
		const BLOCKS_REFRESH_INTERVAL = 3000; // 3 seconds
		const FIAT_CURRENCY = '{{.FiatCurrency}}';
		const workerHashrateFallbackMaxAgeMS = 2 * 60 * 1000;
		const workerHashrateFallback = new Map();
		const workerShareRateFallbackMaxAgeMS = 2 * 60 * 1000;
		const workerShareRateFallback = new Map();

		function workerHashrateKey(worker) {
			const connectionId = String(worker?.connection_id ?? '').trim();
			if (connectionId) {
				return `conn:${connectionId}`;
			}
			const name = String(worker?.name || worker?.display_name || '').trim();
			if (name) {
				return `name:${name}`;
			}
			return '';
		}

		function pruneWorkerHashrateFallback(nowMillis) {
			for (const [key, sample] of workerHashrateFallback.entries()) {
				if (!sample || !Number.isFinite(sample.value) || sample.value <= 0 || !Number.isFinite(sample.at) || nowMillis-sample.at > workerHashrateFallbackMaxAgeMS) {
					workerHashrateFallback.delete(key);
				}
			}
		}

		function pruneWorkerShareRateFallback(nowMillis) {
			for (const [key, sample] of workerShareRateFallback.entries()) {
				if (!sample || !Number.isFinite(sample.value) || sample.value <= 0 || !Number.isFinite(sample.at) || nowMillis-sample.at > workerShareRateFallbackMaxAgeMS) {
					workerShareRateFallback.delete(key);
				}
			}
		}

		function effectiveWorkerHashrate(worker, nowMillis) {
			const key = workerHashrateKey(worker);
			const raw = Number(worker?.rolling_hashrate);
			if (Number.isFinite(raw) && raw > 0) {
				if (key) {
					workerHashrateFallback.set(key, { value: raw, at: nowMillis });
				}
				return raw;
			}
			if (key) {
				const sample = workerHashrateFallback.get(key);
				if (sample && Number.isFinite(sample.value) && sample.value > 0 && Number.isFinite(sample.at) && nowMillis-sample.at <= workerHashrateFallbackMaxAgeMS) {
					return sample.value;
				}
			}
			return 0;
		}

		function effectiveWorkerShareRate(worker, nowMillis) {
			const key = workerHashrateKey(worker);
			const raw = Number(worker?.share_rate);
			if (Number.isFinite(raw) && raw > 0) {
				if (key) {
					workerShareRateFallback.set(key, { value: raw, at: nowMillis });
				}
				return raw;
			}
			if (key) {
				const sample = workerShareRateFallback.get(key);
				if (sample && Number.isFinite(sample.value) && sample.value > 0 && Number.isFinite(sample.at) && nowMillis-sample.at <= workerShareRateFallbackMaxAgeMS) {
					return sample.value;
				}
			}
			return 0;
		}

		function normalizeFiatCurrency(cur) {
			const s = String(cur ?? '').trim();
			return s ? s.toUpperCase() : 'USD';
		}

		function formatFiatNoDecimals(value, currency) {
			const amount = Number(value);
			if (!Number.isFinite(amount)) {
				return null;
			}
			try {
				return new Intl.NumberFormat('en-US', { style: 'currency', currency, maximumFractionDigits: 0 }).format(amount);
			} catch (_) {
				return amount.toFixed(0);
			}
		}

		function formatHashrate(h) {
			if (!h) return '---';
			const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
			let val = h, idx = 0;
			while (val >= 1000 && idx < units.length - 1) {
				val /= 1000;
				idx++;
			}
			return val.toFixed(2) + ' ' + units[idx];
		}

		function hashrateClassForAccuracy(accuracy) {
			const marker = String(accuracy || '').trim();
			if (marker === '~') return 'hashrate-warming';
			if (marker === '≈') return 'hashrate-settling';
			if (marker === '≈+' || marker === '✓' || marker === '') return 'hashrate-solid';
			return '';
		}

		function formatWorkerHashrate(h, accuracy) {
			const base = formatHashrate(h);
			if (base === '---') return '—';
			let marker = String(accuracy || '').trim();
			if (marker === '≈+' || marker === '✓') {
				marker = '';
			}
			return marker ? `${marker} ${base}` : base;
		}

		function formatShareRate(rate) {
			if (!rate) return '0';
			if (rate < 1000) return rate.toFixed(1);
			if (rate < 1000000) return (rate / 1000).toFixed(1) + 'K';
			if (rate < 1000000000) return (rate / 1000000).toFixed(1) + 'M';
			return (rate / 1000000000).toFixed(1) + 'G';
		}

		function formatDiff(d) {
			if (!d) return '—';
			if (d < 1) {
				let prec = Math.ceil(-Math.log10(d)) + 2;
				prec = Math.min(8, Math.max(3, prec));
				const scale = 10 ** prec;
				const trunc = Math.floor(d * scale) / scale;
				let s = trunc.toFixed(prec);
				s = s.replace(/\.?0+$/, '');
				if (s === '0') return d.toExponential(3);
				return s;
			}
			if (d < 1000000) return d.toFixed(0);
			if (d >= 1000000000000) {
				return (d / 1000000000000).toFixed(1) + 'P';
			}
			if (d >= 1000000000) {
				return (d / 1000000000).toFixed(1) + 'G';
			}
			return (d / 1000000).toFixed(1) + 'M';
		}

		function formatBestShareDiff(d) {
			if (!d) return '—';
			if (d >= 1 && d < 100) {
				return d.toFixed(2);
			}
			return formatDiff(d);
		}

		function formatTimeAgo(value) {
			if (!value) return '—';
			const date = new Date(value);
			if (Number.isNaN(date.getTime())) return '—';
			const diffSec = Math.floor((Date.now() - date.getTime()) / 1000);
			if (diffSec < 0) return 'just now';
			if (diffSec < 5) return 'just now';
			if (diffSec < 60) return `${diffSec}s ago`;
			if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m ago`;
			if (diffSec < 86400) return `${Math.floor(diffSec / 3600)}h ago`;
			const days = Math.floor(diffSec / 86400);
			if (days < 7) return `${days}d ago`;
			if (days < 30) return `${Math.floor(days / 7)}w ago`;
			if (days < 365) return `${Math.floor(days / 30)}mo ago`;
			return `${Math.floor(days / 365)}y ago`;
		}

		function formatTimeUntil(value) {
			if (!value) return '—';
			const date = new Date(value);
			if (Number.isNaN(date.getTime())) return '—';
			const diffSec = Math.floor((date.getTime() - Date.now()) / 1000);
			if (Math.abs(diffSec) < 5) return 'just now';
			if (diffSec < 0) {
				return formatTimeAgo(value);
			}
			if (diffSec < 60) return `in ${diffSec}s`;
			if (diffSec < 3600) return `in ${Math.floor(diffSec / 60)}m`;
			if (diffSec < 86400) return `in ${Math.floor(diffSec / 3600)}h`;
			const days = Math.floor(diffSec / 86400);
			if (days < 7) return `in ${days}d`;
			if (days < 30) return `in ${Math.floor(days / 7)}w`;
			if (days < 365) return `in ${Math.floor(days / 30)}mo`;
			return `in ${Math.floor(days / 365)}y`;
		}

		function formatTimeAgoShort(value) {
			if (!value) return '—';
			const date = new Date(value);
			if (Number.isNaN(date.getTime())) return '—';
			const diffSec = Math.floor((Date.now() - date.getTime()) / 1000);
			if (diffSec < 0) return 'now';
			if (diffSec < 5) return 'now';
			if (diffSec < 60) return `${diffSec}s`;
			if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m`;
			if (diffSec < 86400) return `${Math.floor(diffSec / 3600)}h`;
			const days = Math.floor(diffSec / 86400);
			if (days < 7) return `${days}d`;
			if (days < 30) return `${Math.floor(days / 7)}w`;
			if (days < 365) return `${Math.floor(days / 30)}mo`;
			return `${Math.floor(days / 365)}y`;
		}

		function workerSuffix(value) {
			if (!value) return '—';
			const str = String(value);
			const idx = str.indexOf('.');
			if (idx === -1) return str;
			return str.slice(idx);
		}

		function formatBTCShort(sats) {
			const btc = (Number(sats) || 0) / 1e8;
			return `${btc.toFixed(8)} BTC`;
		}

		function shortWallet(value) {
			if (!value) return '—';
			const str = String(value);
			if (str.length <= 12) return str;
			return `${str.slice(0, 6)}...${str.slice(-4)}`;
		}

		function renderWorkersTable(workers) {
			const tbody = document.querySelector('#status-workers-table tbody');
			if (!tbody) return;
				if (!workers || workers.length === 0) {
					tbody.innerHTML = '<tr><td colspan="6" class="text-sm">No worker stats yet.</td></tr>';
					return;
				}
				const nowMillis = Date.now();
				pruneWorkerHashrateFallback(nowMillis);
				pruneWorkerShareRateFallback(nowMillis);
				const rows = workers.map(worker => {
					const name = worker.display_name || worker.name || '—';
					const suffix = workerSuffix(name);
					const shareRate = effectiveWorkerShareRate(worker, nowMillis).toFixed(1);
					const hashrate = effectiveWorkerHashrate(worker, nowMillis);
					const hashrateClass = hashrate > 0 ? hashrateClassForAccuracy(worker.hashrate_accuracy) : '';
					const hashrateText = hashrate > 0 ? formatWorkerHashrate(hashrate, worker.hashrate_accuracy) : '—';
					let connectionId = worker.connection_id ?? '—';
					if (connectionId === '') connectionId = '0';
					return `
						<tr>
							<td class="mono"><span class="worker-full">${name}</span><span class="worker-suffix">${suffix}</span></td>
							<td class="mono">${connectionId}</td>
								<td class="${hashrateClass}">${hashrateText}</td>
							<td>${formatDiff(worker.difficulty)}</td>
							<td>${shareRate}</td>
							<td>${worker.accepted || 0}</td>
						</tr>`;
				});
			tbody.innerHTML = rows.join('');
		}

		function renderBestSharesTable(bestShares) {
			const tbody = document.querySelector('#status-best-shares-table tbody');
			if (!tbody) return;
			if (!bestShares || bestShares.length === 0) {
				tbody.innerHTML = '<tr><td colspan="4" class="text-sm">No high-difficulty shares recorded yet.</td></tr>';
				return;
			}
			const rows = bestShares.map(share => {
				const worker = share.display_worker || share.worker || '—';
				const suffix = workerSuffix(worker);
				return `
					<tr>
						<td class="mono"><span class="worker-full">${worker}</span><span class="worker-suffix">${suffix}</span></td>
						<td>${formatBestShareDiff(share.difficulty)}</td>
						<td><span class="time-full">${formatTimeAgo(share.timestamp)}</span><span class="time-short">${formatTimeAgoShort(share.timestamp)}</span></td>
						<td class="mono">${share.display_hash || share.hash || '—'}</td>
					</tr>
				`;
			});
			tbody.innerHTML = rows.join('');
		}

		function renderFoundBlocksTable(blocks) {
			const tbody = document.querySelector('#status-found-blocks-table tbody');
			if (!tbody) return;
			if (!blocks || blocks.length === 0) {
				tbody.innerHTML = '<tr><td colspan="9" class="text-sm">No blocks found yet.</td></tr>';
				return;
			}
				const rows = blocks.map(block => {
					const confirmations = (typeof block.confirmations === 'number' && block.confirmations > 0)
						? block.confirmations
						: '—';
					const result = String(block.result || '').toLowerCase();
					let resultLabel = 'Possible';
					let resultStyle = 'color:#888;';
					if (result === 'winning') {
						resultLabel = 'Winning';
						resultStyle = 'color:#4ade80;font-weight:600;';
					} else if (result === 'stale') {
						resultLabel = 'Stale';
						resultStyle = 'color:#fca5a5;';
					}
					const worker = block.display_worker || block.worker || '—';
					const suffix = workerSuffix(worker);
					return `
					<tr>
						<td class="mono">${block.height !== undefined ? block.height : '—'}</td>
						<td class="mono">${block.display_hash || block.hash || '—'}</td>
						<td class="mono"><span class="worker-full">${worker}</span><span class="worker-suffix">${suffix}</span></td>
						<td style="${resultStyle}">${resultLabel}</td>
						<td class="mono">${confirmations}</td>
						<td>${block.pool_fee_sats || 0}</td>
						<td>${block.worker_payout_sats || 0}</td>
						<td>${formatDiff(block.share_diff)}</td>
						<td>${formatTimeAgo(block.timestamp)}</td>
					</tr>`;
				});
			tbody.innerHTML = rows.join('');
		}

		function renderMinerTypesList(minerTypes) {
			const list = document.getElementById('status-miner-types-list');
			const placeholder = document.getElementById('status-miner-types-placeholder');
			if (!list || !placeholder) return;
			if (!minerTypes || minerTypes.length === 0) {
				placeholder.textContent = 'No miner type information recorded yet.';
				placeholder.style.display = '';
				list.style.display = 'none';
				list.innerHTML = '';
				return;
			}
			placeholder.style.display = 'none';
			list.style.display = '';
			const entries = minerTypes.map(mt => {
				const versionText = mt.versions && mt.versions.length ?
					mt.versions.map((v, idx) => `${idx ? ', ' : ''}${v.version || '(unknown)'} (${v.workers})`).join('') :
					'(no version info)';
				const total = mt.total_workers || 0;
				return `
					<li>
						<div style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start;">
							<div>
								<span class="mono">${mt.name}</span><br>
								<span class="text-sm">${total} worker${total === 1 ? '' : 's'}</span>
							</div>
							<div class="text-sm mono" style="text-align:right;">
								${versionText}
							</div>
						</div>
					</li>`;
			});
			list.innerHTML = entries.join('');
		}

		function renderBannedWorkersTable(bannedWorkers) {
			const tbody = document.querySelector('#status-banned-workers-table tbody');
			const warning = document.getElementById('status-banned-placeholder-text');
			if (!tbody) return;
			if (!bannedWorkers || bannedWorkers.length === 0) {
				tbody.innerHTML = '<tr><td colspan="2" class="text-sm">No banned workers.</td></tr>';
				if (warning) {
					warning.style.display = 'none';
				}
				return;
			}
			if (warning) {
				warning.style.display = 'none';
			}
			const rows = bannedWorkers.map(worker => {
				const name = worker.display_name || worker.name || '—';
				const banStatus = `<span class="badge">Banned</span><br><span class="label">Until</span> ${formatTimeUntil(worker.banned_until)}${worker.ban_reason ? `<br><span class="label">Reason</span> ${worker.ban_reason}` : ''}`;
				return `
					<tr>
						<td class="mono">${name}</td>
						<td>${banStatus}</td>
					</tr>`;
			});
			tbody.innerHTML = rows.join('');
		}

		function updateGridCards(newData) {
			if (!newData) return;
			const cardContainers = document.querySelectorAll('.grid > .card');
			cardContainers.forEach(card => {
				const label = card.querySelector('.label');
				const valueEl = card.querySelector('.value');
				if (!label || !valueEl) return;
				const labelText = label.textContent.trim();
				switch (labelText) {
					case 'Open connections':
						{
							const total = newData.active_miners ?? 0;
							const tls = newData.active_tls_miners ?? 0;
							valueEl.innerHTML = `${total} <span class="text-sm" style="color:#666;">(${tls} TLS)</span>`;
						}
						break;
					case 'Shares per minute':
						{
							const rate = newData.shares_per_minute ?? 0;
							const workers = newData.active_miners ?? 0;
							const avgPerWorker = workers > 0 ? rate / workers : 0;
							if (workers > 0) {
								valueEl.innerHTML = `${formatShareRate(rate)} <span class="text-sm" style="color:#666;">(${formatShareRate(avgPerWorker)}/worker)</span>`;
							} else {
								valueEl.textContent = formatShareRate(rate);
							}
							const contextEl = card.querySelector('.card-context');
							if (contextEl) {
								if (workers > 0) {
									contextEl.textContent = `${formatShareRate(avgPerWorker)} avg/worker`;
								} else {
									contextEl.textContent = 'Indicative of server load';
								}
							}
						}
						break;
					case 'Estimated pool hashrate':
					case 'Pool hashrate':
						valueEl.textContent = formatHashrate(newData.pool_hashrate);
						break;
				}
			});
		}

		function updateRenderTime(duration) {
			const renderTimeEl = document.getElementById('overview-render-time');
			if (!renderTimeEl || !duration) return;
			const ms = duration / 1000000;
			if (ms < 1) {
				const us = duration / 1000;
				renderTimeEl.textContent = Math.round(us) + 'µs';
				return;
			}
			renderTimeEl.textContent = ms.toFixed(2) + 'ms';
		}

		function normalizePoolTag(tag) {
			if (!tag) return '';
			if (tag[0] === '/') return tag;
			return '/' + tag;
		}

		function updateBTCPrice(newData) {
			if (!newData) return;
			const priceEl = document.getElementById('status-btc-price');
			const updatedEl = document.getElementById('status-btc-price-updated');
			const currency = normalizeFiatCurrency(newData.fiat_currency || FIAT_CURRENCY);
			const price = Number(newData.btc_price_fiat ?? 0);
			window.btcPriceFiat = price;
			window.fiatCurrency = currency;
			if (priceEl) {
				const formatted = price > 0 ? formatFiatNoDecimals(Math.round(price), currency) : null;
				priceEl.textContent = formatted ? ('BTC ' + formatted + ' ' + currency) : '--';
			}
			if (updatedEl) {
				const ts = newData.btc_price_updated_at;
				if (ts) {
					try {
						const d = new Date(ts);
						const millis = d.getTime();
						const ago = formatTimeAgoMillis(millis);
						updatedEl.textContent = ago ? `Updated ${ago}` : 'Updated --';
					} catch (_) {
						updatedEl.textContent = 'Updated --';
					}
				} else {
					updatedEl.textContent = 'Updated --';
				}
			}
		}

		function updateDOM(newData) {
			if (!newData) return;
			const poolTagEl = document.getElementById('status-pool-tag');
			if (poolTagEl) {
				const tag = normalizePoolTag(newData.pool_tag);
				poolTagEl.textContent = tag || '--';
			}
			updateGridCards(newData);
			updateBTCPrice(newData);
			renderWorkersTable(newData.workers);
			renderBestSharesTable(newData.best_shares);
			renderMinerTypesList(newData.miner_types);
			renderBannedWorkersTable(newData.banned_workers);
			updateRenderTime(newData.render_duration);
		}

		function formatUTCTimestamp(isoString) {
			if (!isoString) return 'Loading...';
			try {
				const date = new Date(isoString);
				return 'Data refreshed at ' + date.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
			} catch (e) {
				return 'Loading...';
			}
		}

		function fetchUpdate() {
			fetch('/api/overview')
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					const updatedAt = response.headers.get('X-JSON-Updated-At');
					const dataRefreshedEl = document.getElementById('overview-data-refreshed');
					if (dataRefreshedEl && updatedAt) {
						dataRefreshedEl.textContent = formatUTCTimestamp(updatedAt);
					}
					return response.json();
				})
				.then(data => {
					updateDOM(data);
				})
				.catch(error => {
					console.error('Error fetching status update:', error);
				});
		}

		function fetchBlocksUpdate() {
			fetch('/api/blocks?limit=10')
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					return response.json();
				})
				.then(data => {
					renderFoundBlocksTable(data);
				})
				.catch(error => {
					console.error('Error fetching blocks update:', error);
				});
		}

		fetchUpdate();
		fetchBlocksUpdate();
	setInterval(fetchUpdate, REFRESH_INTERVAL);
	setInterval(fetchBlocksUpdate, BLOCKS_REFRESH_INTERVAL);
	})();
	</script>
	<script>
	(function() {
		const REFRESH_INTERVAL = 5000;
		const valueEl = document.getElementById('status-pool-hashrate');
		const blockHeightEl = document.getElementById('status-block-height');
		const blockHeightContextEl = document.getElementById('status-block-height-context');
		const blockDifficultyEl = document.getElementById('status-block-difficulty');
		const blockTimeLeftEl = document.getElementById('status-block-time-left');
		const blockHistoryEl = document.getElementById('status-block-history');
		const networkHashrateEl = document.getElementById('status-network-hashrate');
		const blockChanceEl = document.getElementById('status-block-chance');
		const templateTxFeesEl = document.getElementById('status-template-tx-fees');
		const templateTxFeesUpdatedEl = document.getElementById('status-template-tx-fees-updated');
		let poolHashrateIncludeHistory = true;
		let blockTimeLeftSec = null;
		let blockTimeOverdueSec = 0;
		let isBlockTimeOverdue = false;
		let templateUpdatedAtMillis = null;
		let templateTxFeesSats = null;
		const BLOCKS_PER_YEAR = 52560;
		const FIAT_CURRENCY = '{{.FiatCurrency}}';
		if (!valueEl) {
			return;
		}

		function formatOddsText(chance) {
			if (!chance || chance <= 0) {
				return '1 in ∞';
			}
			const ratio = 1 / chance;
			if (!Number.isFinite(ratio)) {
				return '1 in ∞';
			}

			const largeUnits = [
				{ value: 1e12, label: 'trillion' },
				{ value: 1e9, label: 'billion' },
				{ value: 1e6, label: 'million' },
			];

			for (const { value, label } of largeUnits) {
				if (ratio >= value) {
					const scaled = ratio / value;
					const precision = scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2;
					const formatted = scaled.toFixed(precision).replace(/\.?0+$/, '');
					return `1 in ${formatted} ${label}`;
				}
			}

			const rounded = Math.max(1, Math.round(ratio));
			return `1 in ${rounded.toLocaleString()}`;
		}

		function formatHashrate(value) {
			if (!value || value <= 0) {
				return '---';
			}
			const units = ['H/s', 'KH/s', 'MH/s', 'GH/s', 'TH/s', 'PH/s', 'EH/s'];
			let val = value;
			let idx = 0;
			while (val >= 1000 && idx < units.length - 1) {
				val /= 1000;
				idx++;
			}
			return `${val.toFixed(2)} ${units[idx]}`;
		}

		function formatDifficulty(diff) {
			if (!diff || diff <= 0) {
				return '--';
			}
			if (diff < 1000000) return diff.toFixed(0);
			if (diff >= 1000000000000000) {
				return (diff / 1000000000000000).toFixed(1) + 'P';
			}
			if (diff >= 1000000000000) {
				return (diff / 1000000000000).toFixed(1) + 'T';
			}
			if (diff >= 1000000000) {
				return (diff / 1000000000).toFixed(1) + 'G';
			}
			return (diff / 1000000).toFixed(1) + 'M';
		}

		function formatDuration(seconds) {
			const total = Math.max(0, Math.floor(seconds ?? 0));
			const hours = Math.floor(total / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;
			if (hours > 0) {
				return `${hours}h ${minutes}m`;
			}
			if (minutes > 0) {
				return `${minutes}m ${secs}s`;
			}
			return `${secs}s`;
		}

		function formatBTCShort(sats) {
			const btc = (Number(sats) || 0) / 1e8;
			return `${btc.toFixed(8)} BTC`;
		}

		function normalizeFiatCurrency(cur) {
			const s = String(cur ?? '').trim();
			return s ? s.toUpperCase() : 'USD';
		}

		function formatFiat(amount, currency) {
			const value = Number(amount);
			if (!Number.isFinite(value)) {
				return null;
			}
			try {
				return new Intl.NumberFormat('en-US', { style: 'currency', currency, maximumFractionDigits: 2 }).format(value);
			} catch (_) {
				return '$' + value.toFixed(2);
			}
		}

		function formatHHMMSSUTC(millis) {
			if (typeof millis !== 'number' || !Number.isFinite(millis)) {
				return null;
			}
			const date = new Date(millis);
			if (Number.isNaN(date.getTime())) {
				return null;
			}
			return date.toISOString().substring(11, 19) + ' UTC';
		}

		function formatTimeAgoMillis(millis) {
			if (typeof millis !== 'number' || !Number.isFinite(millis)) {
				return null;
			}
			const diffSec = Math.floor((Date.now() - millis) / 1000);
			if (diffSec < 0) return 'just now';
			if (diffSec < 5) return 'just now';
			if (diffSec < 60) return `${diffSec}s ago`;
			if (diffSec < 3600) return `${Math.floor(diffSec / 60)}m ago`;
			if (diffSec < 86400) return `${Math.floor(diffSec / 3600)}h ago`;
			const days = Math.floor(diffSec / 86400);
			if (days < 7) return `${days}d ago`;
			if (days < 30) return `${Math.floor(days / 7)}w ago`;
			if (days < 365) return `${Math.floor(days / 30)}mo ago`;
			return `${Math.floor(days / 365)}y ago`;
		}

		function renderTemplateTxFees() {
			if (!templateTxFeesEl) {
				return;
			}
				if (typeof templateTxFeesSats !== 'number' || templateTxFeesSats < 0) {
					templateTxFeesEl.textContent = '--';
					if (templateTxFeesUpdatedEl) {
						templateTxFeesUpdatedEl.textContent = 'Updated --';
					}
					return;
				}
			const btcText = formatBTCShort(templateTxFeesSats);
			const currency = normalizeFiatCurrency(window.fiatCurrency || FIAT_CURRENCY);
			const priceFiat = Number(window.btcPriceFiat ?? 0);
			const fiatText = priceFiat > 0 ? formatFiat((Number(templateTxFeesSats) / 1e8) * priceFiat, currency) : null;
			templateTxFeesEl.innerHTML = fiatText
				? `${btcText}<br><span style="opacity:0.7; font-size:0.85em;">(${fiatText} ${currency})</span>`
				: btcText;
			if (templateTxFeesUpdatedEl) {
				const ago = formatTimeAgoMillis(templateUpdatedAtMillis);
				templateTxFeesUpdatedEl.textContent = ago ? `Updated ${ago}` : 'Updated --';
			}
		}

		function formatDurationDetailed(seconds) {
			const total = Math.max(0, Math.floor(seconds ?? 0));
			const days = Math.floor(total / 86400);
			const hours = Math.floor((total % 86400) / 3600);
			const minutes = Math.floor((total % 3600) / 60);
			const secs = total % 60;

			const parts = [];
			if (days > 0) parts.push(`${days}d`);
			if (hours > 0) parts.push(`${hours}h`);
			if (minutes > 0) parts.push(`${minutes}m`);
			if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);

			return parts.slice(0, 3).join(' ');
		}

		function getUpdatedAtMillis(value) {
			if (!value) {
				return null;
			}
			const parsed = Date.parse(value);
			if (Number.isNaN(parsed)) {
				return null;
			}
			return parsed;
		}

		function renderBlockTimeLeft() {
			if (!blockTimeLeftEl) {
				return;
			}
			if (isBlockTimeOverdue) {
				blockTimeLeftEl.textContent = `overdue ${formatDuration(blockTimeOverdueSec)}`;
				return;
			}
			if (typeof blockTimeLeftSec !== 'number') {
				blockTimeLeftEl.textContent = '--';
				return;
			}
			blockTimeLeftEl.textContent = formatDuration(blockTimeLeftSec);
		}

		function renderBlockHistory(recentBlockTimes) {
			if (!blockHistoryEl) {
				return;
			}
			if (!recentBlockTimes || recentBlockTimes.length === 0) {
				blockHistoryEl.innerHTML = '--';
				return;
			}

			// Calculate previous block durations from timestamps
			// With 4 timestamps [t0, t1, t2, t3], we show the 3 previous block durations:
			// - (t3 - t2): most recent previous block
			// - (t2 - t1): 2nd previous
			// - (t1 - t0): 3rd previous
			const durations = [];
			for (let i = recentBlockTimes.length - 1; i >= 1; i--) {
				const prev = new Date(recentBlockTimes[i - 1]).getTime();
				const curr = new Date(recentBlockTimes[i]).getTime();
				const durationSec = Math.floor((curr - prev) / 1000);
				if (durationSec <= 0) {
					durations.push('timestamp skew');
				} else {
					durations.push(formatDurationDetailed(durationSec));
				}
				// Stop after 3 durations
				if (durations.length >= 3) break;
			}

			if (durations.length === 0) {
				blockHistoryEl.innerHTML = '--';
			} else {
				// Render left-to-right to save vertical space.
				blockHistoryEl.textContent = durations.join(' | ');
			}
		}

		function updateHashrateDisplay(rate) {
			const formatted = formatHashrate(rate);
			if (valueEl.textContent !== formatted) {
				valueEl.textContent = formatted;
			}
		}

		function fetchHashrate() {
			const endpoint = poolHashrateIncludeHistory ? '/api/pool-hashrate?include_history=1' : '/api/pool-hashrate';
			fetch(endpoint)
				.then(response => {
					if (!response.ok) throw new Error('Network response was not ok');
					const updatedAt = response.headers.get('X-JSON-Updated-At');
					return response.json().then(data => ({ data, updatedAt }));
				})
					.then(({ data, updatedAt }) => {
						if (poolHashrateIncludeHistory) {
							poolHashrateIncludeHistory = false;
						}
						const primedFromHistory = !!(window.primeHashrateGraphHistory &&
							Array.isArray(data?.pool_hashrate_history) &&
							window.primeHashrateGraphHistory(data.pool_hashrate_history));
						const heightForGraph = typeof data?.block_height === 'number' && data.block_height > 0 ? data.block_height : null;
						if (data && typeof data.pool_hashrate === 'number') {
							updateHashrateDisplay(data.pool_hashrate);
							if (window.updateHashrateGraph && data.pool_hashrate > 0 && !primedFromHistory) {
								window.updateHashrateGraph(data.pool_hashrate, heightForGraph);
							}
						}
						if (data && typeof data.template_tx_fees_sats === 'number') {
							templateTxFeesSats = data.template_tx_fees_sats;
						} else {
						templateTxFeesSats = null;
					}
					templateUpdatedAtMillis = getUpdatedAtMillis(data?.template_updated_at) ?? getUpdatedAtMillis(updatedAt || data?.updated_at);
					renderTemplateTxFees();
					if (blockHeightEl && typeof data.block_height === 'number' && data.block_height > 0) {
						const height = data.block_height;
						blockHeightEl.textContent = height.toLocaleString();
						if (blockHeightContextEl) {
							const retarget = data.next_difficulty_retarget;
								if (retarget && typeof retarget.height === 'number' && retarget.height > 0) {
									const parts = [];
									if (typeof retarget.blocks_away === 'number') {
										parts.push(null);
									}
									if (retarget.duration_estimate) {
										parts.push(`~${retarget.duration_estimate}`);
									}
									if (parts.length === 0) {
										parts.push('~--');
									}
									const summary = parts.filter(Boolean).join(' · ');
									blockHeightContextEl.innerHTML = `${retarget.height.toLocaleString()}<br><span class="text-sm" style="color:var(--text-muted);">(${summary})</span>`;
							} else {
								const interval = 2016;
								const next = (Math.floor(height / interval) + 1) * interval;
								const remaining = Math.max(0, next - height);
								const durationSeconds = remaining * 10 * 60;
								const durationText = formatDuration(durationSeconds);
								blockHeightContextEl.innerHTML = `${next.toLocaleString()}<br><span class="text-sm" style="color:var(--text-muted);">(~${durationText})</span>`;
							}
						}
					} else if (blockHeightEl) {
						blockHeightEl.textContent = '--';
						if (blockHeightContextEl) {
							blockHeightContextEl.textContent = 'Current chain tip';
						}
					}
					let networkHashrate = null;
					if (blockDifficultyEl && typeof data.block_difficulty === 'number') {
						blockDifficultyEl.textContent = formatDifficulty(data.block_difficulty);
						networkHashrate = data.block_difficulty * 4294967296 / (10 * 60);
					}
					if (networkHashrateEl) {
						const networkHashrateText = networkHashrate ? formatHashrate(networkHashrate) : '--';
						networkHashrateEl.textContent = networkHashrateText;
					}
					if (blockChanceEl) {
						let chanceText = '--';
						if (networkHashrate && typeof data.pool_hashrate === 'number' && data.pool_hashrate > 0) {
							const share = Math.min(1, data.pool_hashrate / networkHashrate);
							const chance = 1 - Math.pow(1 - share, BLOCKS_PER_YEAR);
							chanceText = formatOddsText(chance);
						}
						blockChanceEl.textContent = chanceText;
					}
					if (blockTimeLeftEl) {
						let secondsLeft = null;

						// Try to use block_time_left_sec from server if available
						if (typeof data.block_time_left_sec === 'number' && data.block_time_left_sec >= 0) {
							secondsLeft = data.block_time_left_sec;
							const updatedMillis = getUpdatedAtMillis(updatedAt || data.updated_at);
							if (updatedMillis !== null) {
								const ageSec = Math.max(0, (Date.now() - updatedMillis) / 1000);
								secondsLeft = secondsLeft - ageSec;
							}
						}
						// Fall back to calculating from most recent block timestamp
						else if (data.recent_block_times && data.recent_block_times.length > 0) {
							const mostRecentBlockTime = new Date(data.recent_block_times[data.recent_block_times.length - 1]).getTime();
							const targetInterval = 10 * 60 * 1000; // 10 minutes in ms
							const expectedEndTime = mostRecentBlockTime + targetInterval;
							secondsLeft = Math.floor((expectedEndTime - Date.now()) / 1000);
						}

						if (secondsLeft === null) {
							blockTimeLeftSec = null;
							isBlockTimeOverdue = false;
							blockTimeOverdueSec = 0;
						} else if (secondsLeft <= 0) {
							blockTimeLeftSec = 0;
							isBlockTimeOverdue = true;
							blockTimeOverdueSec = Math.floor(Math.max(0, -secondsLeft));
						} else {
							blockTimeLeftSec = secondsLeft;
							isBlockTimeOverdue = false;
							blockTimeOverdueSec = 0;
						}
						renderBlockTimeLeft();
					}
					if (data.recent_block_times) {
						renderBlockHistory(data.recent_block_times);
					}
				})
				.catch(err => {
					console.error('Error fetching pool hashrate:', err);
				});
		}

		fetchHashrate();
		setInterval(fetchHashrate, REFRESH_INTERVAL);
		setInterval(() => {
			renderTemplateTxFees();
			if (typeof blockTimeLeftSec !== 'number') {
				return;
			}
			if (isBlockTimeOverdue) {
				blockTimeOverdueSec += 1;
			} else {
				blockTimeLeftSec -= 1;
				if (blockTimeLeftSec <= 0) {
					blockTimeLeftSec = 0;
					isBlockTimeOverdue = true;
					blockTimeOverdueSec = 0;
				}
			}
			renderBlockTimeLeft();
		}, 1000);
	})();
	</script>
	<script>
			;(function () {
				const banner = document.getElementById("overview-banner");
				if (!banner) {
					return;
				}
				const connectPanel = banner.querySelector(".connect-panel");
				const foldToggle = document.getElementById("connect-panel-fold-toggle");

				function applyFoldState(folded) {
					if (!connectPanel || !foldToggle) {
						return;
					}
					connectPanel.dataset.folded = folded ? "true" : "false";
					foldToggle.textContent = folded ? "show info" : "hide info";
					foldToggle.setAttribute("aria-expanded", folded ? "false" : "true");
					foldToggle.setAttribute("aria-label", folded ? "Expand connect steps" : "Collapse connect steps");
				}

				if (connectPanel && foldToggle) {
					applyFoldState(true);
					foldToggle.addEventListener("click", () => {
						const nextFolded = connectPanel.dataset.folded !== "true";
						applyFoldState(nextFolded);
					});
				}

			const host = banner.dataset.host || window.location.hostname || "localhost";
			banner.querySelectorAll("[data-stratum-host]").forEach(el => {
				el.textContent = host;
			});

		const feedbackTimers = new WeakMap();
		const FEEDBACK_DURATION = 3400;

		function showCopyFeedback(feedbackEl) {
			if (!feedbackEl) {
				return;
			}
			feedbackEl.textContent = "Copied";
			feedbackEl.classList.add("visible");
			if (feedbackTimers.has(feedbackEl)) {
				clearTimeout(feedbackTimers.get(feedbackEl));
			}
			const timer = setTimeout(() => {
				feedbackEl.classList.remove("visible");
			}, FEEDBACK_DURATION);
			feedbackTimers.set(feedbackEl, timer);
		}

		async function copyToClipboard(value) {
			if (!value) {
				return;
			}
			if (navigator.clipboard && navigator.clipboard.writeText) {
				await navigator.clipboard.writeText(value);
				return;
			}
			const textarea = document.createElement("textarea");
			textarea.value = value;
			textarea.setAttribute("readonly", "");
			textarea.style.position = "fixed";
			textarea.style.opacity = "0";
			banner.appendChild(textarea);
			textarea.select();
			textarea.setSelectionRange(0, textarea.value.length);
			try {
				document.execCommand("copy");
			} catch (err) {
				console.error("Copy fallback failed", err);
			}
			banner.removeChild(textarea);
		}

		function feedbackForButton(button) {
			const row = button.closest(".connect-copy-row");
			if (row) {
				return row.querySelector(".copy-feedback");
			}
			if (button.nextElementSibling && button.nextElementSibling.classList && button.nextElementSibling.classList.contains("copy-feedback")) {
				return button.nextElementSibling;
			}
			return null;
		}

		banner.querySelectorAll(".stratum-copy").forEach(button => {
			const scheme = button.dataset.copyScheme || "";
			const port = button.dataset.copyPort || "";
			const feedbackEl = feedbackForButton(button);
			button.addEventListener("click", async () => {
				if (!scheme || !port) return;
				const value = `${scheme}${host}:${port}`;
				try {
					await copyToClipboard(value);
					showCopyFeedback(feedbackEl);
				} catch (err) {
					console.error("Failed to copy stratum address:", err);
				}
			});
		});

	})();
	</script>
</body>
</html>
